---
tags: bilibili_note
url: https://www.bilibili.com/video/BV17F411T7Ao
down_time: 2024-1-4 21:56:30
---

![https://api.bilibili.com/x/note/image?image_id=410836](https://api.bilibili.com/x/note/image?image_id=410836)
1.4之后就直接5-17
---
C:\Program Files\Common Files\Oracle\Java\javapath
[🚩Java入门-10-Java学习-环境变量 P10 - 02:21](https://www.bilibili.com/video/BV17F411T7Ao?p=10&t=140)
[🚩Java入门-10-Java学习-环境变量 P10 - 02:50](https://www.bilibili.com/video/BV17F411T7Ao?p=10&t=169)


可以直接 java xxx.java


![https://api.bilibili.com/x/note/image?image_id=408793](https://api.bilibili.com/x/note/image?image_id=408793)


![https://api.bilibili.com/x/note/image?image_id=408794](https://api.bilibili.com/x/note/image?image_id=408794)
---
LTS：java 5、8、17
在SE（标准版）的基础上，有EE（企业版）和ME（小型版）。
![https://api.bilibili.com/x/note/image?image_id=408795](https://api.bilibili.com/x/note/image?image_id=408795)
java跨平台靠JVM，java程序运行在JVM里，而不是直接运行在计算机上。
JDK（java开发工具包）：JVM，核心类库，运行工具（javac,java,jhat等）
JRE（java运行环境）：JVM，核心类库，运行工具（javac,java,jhat等），但是精简掉开发的东西。JDK包含了JRE。


---
java的关键字全部小写。
---
字面量（4类基本数据类型和一个null类型）
- 字符类型，个数必须是一个。''和'ABC'都不行，'中'可以。
- null不能打印，        System.out.println(null);

![https://api.bilibili.com/x/note/image?image_id=408836](https://api.bilibili.com/x/note/image?image_id=408836)


![https://api.bilibili.com/x/note/image?image_id=408838](https://api.bilibili.com/x/note/image?image_id=408838)


![https://api.bilibili.com/x/note/image?image_id=408840](https://api.bilibili.com/x/note/image?image_id=408840)
Java语言的数据类型分为:基本数据类型(4类8种)，引用数据类型（数组、类、String、接口）
注意：String不是基本数据类型，而是引用数据类型。


基本数据类型和引用数据类型
- 基本数据类型，栈中存变量名和数据值。
- 引用数据类型。栈中存变量名和地址值，堆中存new的数据值。



![https://api.bilibili.com/x/note/image?image_id=408841](https://api.bilibili.com/x/note/image?image_id=408841)
lL, fF.




![https://api.bilibili.com/x/note/image?image_id=409159](https://api.bilibili.com/x/note/image?image_id=409159)
转换主要是，整型和浮点型。还有char类型，&nbsp; int a &nbsp;= 'a'; // 97
没有布尔型，int a = true。


---
标识符
 
![https://api.bilibili.com/x/note/image?image_id=408842](https://api.bilibili.com/x/note/image?image_id=408842)
---
![https://api.bilibili.com/x/note/image?image_id=408844](https://api.bilibili.com/x/note/image?image_id=408844)
---
模块/src/com.包名/类
![https://api.bilibili.com/x/note/image?image_id=408845](https://api.bilibili.com/x/note/image?image_id=408845)
---
10/3 = 3, 10.0/3 = 3.3333333333333
![https://api.bilibili.com/x/note/image?image_id=408856](https://api.bilibili.com/x/note/image?image_id=408856)
注意：转换规则2.
byte a = 10;
byte b = 20;
int c = a + b;
// byte d = a + b; // error
byte d = (a + b);
![https://api.bilibili.com/x/note/image?image_id=409068](https://api.bilibili.com/x/note/image?image_id=409068)


![https://api.bilibili.com/x/note/image?image_id=409072](https://api.bilibili.com/x/note/image?image_id=409072)
---
逻辑运算符：&amp;,|,^,!
短路逻辑运算符：&amp;&amp;,||
短路逻辑运算符，只要左边确定就不运算右边（&amp;&amp;左假则假，||左真则真）
---


swith jdk的区别。
![https://api.bilibili.com/x/note/image?image_id=409139](https://api.bilibili.com/x/note/image?image_id=409139)
同样的case可以写在一起：
![https://api.bilibili.com/x/note/image?image_id=409146](https://api.bilibili.com/x/note/image?image_id=409146)
jdk12的特性：用箭头，简化break
![https://api.bilibili.com/x/note/image?image_id=409141](https://api.bilibili.com/x/note/image?image_id=409141)
还能接受case（包括default）返回的值。
![https://api.bilibili.com/x/note/image?image_id=409143](https://api.bilibili.com/x/note/image?image_id=409143)
---
考虑隐式转换：
int[] a = {byte, short ,int , char}, 没有{boolean, float, double}
int[] a = {(byte)1, (short)2, 3, 'a'};
double[] b = {byte, short, int, long, float, double, char}, 没有{boolean}
![https://api.bilibili.com/x/note/image?image_id=409156](https://api.bilibili.com/x/note/image?image_id=409156)
数组名和[] 没有先后顺序
![https://api.bilibili.com/x/note/image?image_id=409161](https://api.bilibili.com/x/note/image?image_id=409161)


![https://api.bilibili.com/x/note/image?image_id=409516](https://api.bilibili.com/x/note/image?image_id=409516)
静态数组初始化：`int[] a = {1,2,3};`只是`int[] a = new int[]{1,2,3};`的简写。
注意，这里可没有强制类型转化，`int[] a = new int[] {3.14};`报错
注意，没有`int[3] a = {1, 2, 3};`，java 的静态初始化只能是知道所有的元素。


动态数组初始化：`int[] b = new int[3];`
可动态变量来指定大小，`new int[n]`
动态数组的默认初始化值：


![https://api.bilibili.com/x/note/image?image_id=409306](https://api.bilibili.com/x/note/image?image_id=409306)
每行的地址先是null，null再自动被每列的地址所取代。
![https://api.bilibili.com/x/note/image?image_id=409522](https://api.bilibili.com/x/note/image?image_id=409522)


![https://api.bilibili.com/x/note/image?image_id=409524](https://api.bilibili.com/x/note/image?image_id=409524)
特殊情况一，不等长二维数组：每行先保存null，再被手动取代。
![https://api.bilibili.com/x/note/image?image_id=409525](https://api.bilibili.com/x/note/image?image_id=409525)


![https://api.bilibili.com/x/note/image?image_id=409526](https://api.bilibili.com/x/note/image?image_id=409526)
特殊情况二：取代原默认数组的地址。
![https://api.bilibili.com/x/note/image?image_id=409527](https://api.bilibili.com/x/note/image?image_id=409527)


![https://api.bilibili.com/x/note/image?image_id=409528](https://api.bilibili.com/x/note/image?image_id=409528)
数组的地址：
![https://api.bilibili.com/x/note/image?image_id=409302](https://api.bilibili.com/x/note/image?image_id=409302)
----
内存分配：
JVM在内存中占据一部分空间。
JVM的内部分为，堆、栈、方法区、本地方法栈、寄存器
![https://api.bilibili.com/x/note/image?image_id=409346](https://api.bilibili.com/x/note/image?image_id=409346)
JDK7前，堆和方法区是连在一起的。实际物理上也是连在一起的。
![https://api.bilibili.com/x/note/image?image_id=409341](https://api.bilibili.com/x/note/image?image_id=409341)
JDK8, 取消方法区，设立元空间。
![https://api.bilibili.com/x/note/image?image_id=409344](https://api.bilibili.com/x/note/image?image_id=409344)


![https://api.bilibili.com/x/note/image?image_id=409348](https://api.bilibili.com/x/note/image?image_id=409348)
当方法出栈后，方法中在栈里的变量也都出栈了。
![https://api.bilibili.com/x/note/image?image_id=409364](https://api.bilibili.com/x/note/image?image_id=409364)
 方法调用方法。
![https://api.bilibili.com/x/note/image?image_id=409368](https://api.bilibili.com/x/note/image?image_id=409368)
数组new的部分在堆中。
![https://api.bilibili.com/x/note/image?image_id=409349](https://api.bilibili.com/x/note/image?image_id=409349)




![https://api.bilibili.com/x/note/image?image_id=409352](https://api.bilibili.com/x/note/image?image_id=409352)
方法区详细：
- 加载 `.class` 字节码文件，并临时存储class文件内的成员变量、成员方法、类方法等。这些临时存储的东西，到时会被放入栈内存中。
- 元空间负责加载字节码文件



![https:https://api.bilibili.com/x/note/image?image_id=409599](https:https://api.bilibili.com/x/note/image?image_id=409599)
[🚩面向对象-07-三种情况的对象内存图 P87 - 14:04](https://www.bilibili.com/video/BV17F411T7Ao?p=87&t=843)


![https://api.bilibili.com/x/note/image?image_id=409608](https://api.bilibili.com/x/note/image?image_id=409608)
[🚩面向对象-07-三种情况的对象内存图 P87 - 21:38](https://www.bilibili.com/video/BV17F411T7Ao?p=87&t=1298)


![https://api.bilibili.com/x/note/image?image_id=409613](https://api.bilibili.com/x/note/image?image_id=409613)
[🚩面向对象-07-三种情况的对象内存图 P87 - 28:28](https://www.bilibili.com/video/BV17F411T7Ao?p=87&t=1708)


![https://api.bilibili.com/x/note/image?image_id=409615](https://api.bilibili.com/x/note/image?image_id=409615)
----
方法：
1. 因为Java都是类，所以无所谓写的位置先后。
2. 方法必须绑定类，所以不能互相嵌套定义。

![https://api.bilibili.com/x/note/image?image_id=409356](https://api.bilibili.com/x/note/image?image_id=409356)
---
方法重载：
1. 同一类中的同名方法。
2. 参数不同：个数，类型。与参数具体名字无关。
3. 与返回值无关。

---
![https://api.bilibili.com/x/note/image?image_id=409531](https://api.bilibili.com/x/note/image?image_id=409531)
 权限修饰符，修饰成员变量和成员方法。
public, private, protected.
private 成员变量 + public set/get方法


无参构造方法：
- 系统将给出一个默认的无参数构造方法
- 如果定义了构造方法（不管无参还是有参），系统将不再提供默认的构造方法
- 建议写了有参，也写上无参的。

![https://api.bilibili.com/x/note/image?image_id=409539](https://api.bilibili.com/x/note/image?image_id=409539)
this
![https://api.bilibili.com/x/note/image?image_id=409616](https://api.bilibili.com/x/note/image?image_id=409616)


![https://api.bilibili.com/x/note/image?image_id=409618](https://api.bilibili.com/x/note/image?image_id=409618)


![https://api.bilibili.com/x/note/image?image_id=409637](https://api.bilibili.com/x/note/image?image_id=409637)
----
![https://api.bilibili.com/x/note/image?image_id=410716](https://api.bilibili.com/x/note/image?image_id=410716)
创建了几个字符串
![https://api.bilibili.com/x/note/image?image_id=410717](https://api.bilibili.com/x/note/image?image_id=410717)
s6额外产生了4个字符串
![https://api.bilibili.com/x/note/image?image_id=410772](https://api.bilibili.com/x/note/image?image_id=410772)
有几种创建String对象的方式：
![https://api.bilibili.com/x/note/image?image_id=410718](https://api.bilibili.com/x/note/image?image_id=410718)


![https://api.bilibili.com/x/note/image?image_id=410719](https://api.bilibili.com/x/note/image?image_id=410719)
具体区别：
- 串池StringTable：字符串常量池，作用是复用。但只有直接赋值的才在这里`String a = "abc";`，而new的不在这里。

![https://api.bilibili.com/x/note/image?image_id=410723](https://api.bilibili.com/x/note/image?image_id=410723)


![https://api.bilibili.com/x/note/image?image_id=410724](https://api.bilibili.com/x/note/image?image_id=410724)
- `String a = new String("abc");`：不会复用。所以一般都直接赋值的方式。

![https://api.bilibili.com/x/note/image?image_id=410727](https://api.bilibili.com/x/note/image?image_id=410727)
---
比较String
![https://api.bilibili.com/x/note/image?image_id=410728](https://api.bilibili.com/x/note/image?image_id=410728)
```java
String a = "abc";
String b = "abc";
String c = new String("abc");
String d = new String("abc");
// 串池复用而的地址都一样
System.out.println(a == b); &nbsp; &nbsp; &nbsp; &nbsp; // true
// 一个串池，一个new的，地址肯定不一样
System.out.println(a == c); &nbsp; &nbsp; &nbsp; &nbsp; // false
// new的不复用而地址不一样
System.out.println(c == d); &nbsp; &nbsp; &nbsp; &nbsp; // false
System.out.println(a.equals(b)); &nbsp; &nbsp;// true
System.out.println(a.equals(c)); &nbsp; &nbsp;// true
System.out.println(c.equals(d)); &nbsp; &nbsp;// true
```
![https://api.bilibili.com/x/note/image?image_id=410732](https://api.bilibili.com/x/note/image?image_id=410732)
`sc.next()`的内部源码是 `new String(xxx)`
![https://api.bilibili.com/x/note/image?image_id=410740](https://api.bilibili.com/x/note/image?image_id=410740)
---
Java的String没有索引`[]`，只有`.charAt()`方法。
修改字符也不能通过索引，而是要转化为char字符数组。


---
subString()方法
![https:https://api.bilibili.com/x/note/image?image_id=410831](https:https://api.bilibili.com/x/note/image?image_id=410831)
---
StringBuilder: 快速拼接字符串。
不像String会产生中间无用的字符串，而是类型容器，拼接完了才产生字符串。
![https://api.bilibili.com/x/note/image?image_id=410786](https://api.bilibili.com/x/note/image?image_id=410786)


![https://api.bilibili.com/x/note/image?image_id=410791](https://api.bilibili.com/x/note/image?image_id=410791)


![https://api.bilibili.com/x/note/image?image_id=410820](https://api.bilibili.com/x/note/image?image_id=410820)
小技巧：链式编程，即连续append
![https://api.bilibili.com/x/note/image?image_id=410825](https://api.bilibili.com/x/note/image?image_id=410825)


![https://api.bilibili.com/x/note/image?image_id=410822](https://api.bilibili.com/x/note/image?image_id=410822)
 StringJoiner()：简化元素分隔字符的代码。
![https://api.bilibili.com/x/note/image?image_id=410832](https://api.bilibili.com/x/note/image?image_id=410832)


![https://api.bilibili.com/x/note/image?image_id=410833](https://api.bilibili.com/x/note/image?image_id=410833)


![https://api.bilibili.com/x/note/image?image_id=410834](https://api.bilibili.com/x/note/image?image_id=410834)


![https://api.bilibili.com/x/note/image?image_id=410835](https://api.bilibili.com/x/note/image?image_id=410835)
---
![https://api.bilibili.com/x/note/image?image_id=410877](https://api.bilibili.com/x/note/image?image_id=410877)
字符串拼接的底层原理：分为没有变量和有变量的拼接情况
- 没有变量：会复用串池

![https://api.bilibili.com/x/note/image?image_id=410838](https://api.bilibili.com/x/note/image?image_id=410838)
- 有变量时，高低版本都是new String。

通过StringBuilder。最终StringBuilder的toString()的结果是会new String()。
![https://api.bilibili.com/x/note/image?image_id=410840](https://api.bilibili.com/x/note/image?image_id=410840)
但JDK8前，为什么默认`+`拼接同样用StringBuilder，但比手动用StringBuilder慢？因为每次`+`拼接，都会创建新的StringBuilder对象和中间String对象。
具体是，`s1+"b"`, s1→StringBuilder, add()后再toString()得到String对象。
![https:https://api.bilibili.com/x/note/image?image_id=410839](https:https://api.bilibili.com/x/note/image?image_id=410839)


![https:https://api.bilibili.com/x/note/image?image_id=410841](https:https://api.bilibili.com/x/note/image?image_id=410841)
JDK8后， 编译器会预估最终字符串的长度（将各String对象的字符串长度相加），创建一个字符数组，最终将其变成new String对象。
然而，预估也是需要时间。比如，左边只需要预估一次，而右边需要预估两次。
![https://api.bilibili.com/x/note/image?image_id=410851](https://api.bilibili.com/x/note/image?image_id=410851)
面试题：
![https://api.bilibili.com/x/note/image?image_id=410852](https://api.bilibili.com/x/note/image?image_id=410852)


![https://api.bilibili.com/x/note/image?image_id=410853](https://api.bilibili.com/x/note/image?image_id=410853)


![https://api.bilibili.com/x/note/image?image_id=410864](https://api.bilibili.com/x/note/image?image_id=410864)
[🚩字符串-12-字符串相关类的底层原理 P107 - 38:02](https://www.bilibili.com/video/BV17F411T7Ao?p=107&t=2282)
StringBuilder最大容量是int上限。
---
集合
![https://api.bilibili.com/x/note/image?image_id=410902](https://api.bilibili.com/x/note/image?image_id=410902)




![https://api.bilibili.com/x/note/image?image_id=410910](https://api.bilibili.com/x/note/image?image_id=410910)


![https://api.bilibili.com/x/note/image?image_id=410905](https://api.bilibili.com/x/note/image?image_id=410905)
```java
//1.创建集合的对象
//泛型：限定集合中存储数据的类型
//ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();
//JDK7:


//打印对象不是地址值，而是集合中存储数据内容
ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
```
任意类型
![https://api.bilibili.com/x/note/image?image_id=412583](https://api.bilibili.com/x/note/image?image_id=412583)


![https://api.bilibili.com/x/note/image?image_id=410903](https://api.bilibili.com/x/note/image?image_id=410903)
---
[🚩面向对象进阶-01-static-静态变量 P121 - 17:53](https://www.bilibili.com/video/BV17F411T7Ao?p=121&t=1072)


static:
- 当.class字节码文件被加载到方法区后，并创建静态区（单独存放静态变量的空间。jdk7前，不管静态还是成员变量都在方法区；jdk7起，静态变量在堆内存。PS：静态方法还是在方法区）。静态区存放此类的所有静态变量，并默认初始化。
- 随着类的加载而加载，优先于对象存在。
- 静态方案只能访问静态（静态方法和静态变量）。



---
this参数：
![https://api.bilibili.com/x/note/image?image_id=412107](https://api.bilibili.com/x/note/image?image_id=412107)
成员方法的参数列表有一个隐藏的this，写不写都行，实参由JVM传入。
而静态方法则没有this关键字。
---
main函数
![https://api.bilibili.com/x/note/image?image_id=412109](https://api.bilibili.com/x/note/image?image_id=412109)


![https://api.bilibili.com/x/note/image?image_id=412110](https://api.bilibili.com/x/note/image?image_id=412110)


![https://api.bilibili.com/x/note/image?image_id=412111](https://api.bilibili.com/x/note/image?image_id=412111)


![https://api.bilibili.com/x/note/image?image_id=412112](https://api.bilibili.com/x/note/image?image_id=412112)


![https://api.bilibili.com/x/note/image?image_id=412113](https://api.bilibili.com/x/note/image?image_id=412113)
   
![https://api.bilibili.com/x/note/image?image_id=412114](https://api.bilibili.com/x/note/image?image_id=412114)




![https://api.bilibili.com/x/note/image?image_id=412116](https://api.bilibili.com/x/note/image?image_id=412116)


![https://api.bilibili.com/x/note/image?image_id=412123](https://api.bilibili.com/x/note/image?image_id=412123)
1. 子类不能继承父类的构造方法（因为子类和父类的构造方法名字都不一样），但可以调用。
2. 子类可以继承父类的所有成员变量。
&nbsp; &nbsp; 子类可以继承父类的私有成员变量，但是不能直接访问，需要通过父类的公有方法访问。
3. 子类可以继承父类的非私有成员方法，不能继承私有成员方法（因为不能被添加到虚方法表中）。
4. static、final修饰的方法都不能继承（因为不能被添加到虚方法表中）。
【内存图】
[🚩面向对象进阶-06-子类到底能继承... P126 - 14:02](https://www.bilibili.com/video/BV17F411T7Ao?p=126&t=842)
内存分析工具：
[🚩面向对象进阶-06-子类到底能继承... P126 - 37:56](https://www.bilibili.com/video/BV17F411T7Ao?p=126&t=2276)


---
虚方法（非private、非static、非final）：有了虚方法，就不用沿着继承关系一层一层往上找，而是从父到子一层层往下传递虚方法表，最终子类就直接从自己的虚方法表（包含自己的虚方法）中查找。
所以，①判断是不是虚方法；②是虚方法，则从虚方法表中查找；③如果虚方法中没有，才往上找。
Object有5个虚方法。
![https://api.bilibili.com/x/note/image?image_id=412537](https://api.bilibili.com/x/note/image?image_id=412537)
【内存图】
[🚩面向对象进阶-06-子类到底能继承... P126 - 31:53](https://www.bilibili.com/video/BV17F411T7Ao?p=126&t=1913)


![https://api.bilibili.com/x/note/image?image_id=412538](https://api.bilibili.com/x/note/image?image_id=412538)


![https://api.bilibili.com/x/note/image?image_id=412539](https://api.bilibili.com/x/note/image?image_id=412539)


![https://api.bilibili.com/x/note/image?image_id=412540](https://api.bilibili.com/x/note/image?image_id=412540)
方法重写：覆盖虚方法表中的方法
![https://api.bilibili.com/x/note/image?image_id=412541](https://api.bilibili.com/x/note/image?image_id=412541)
@Override让JVM检查语法
![https://api.bilibili.com/x/note/image?image_id=412542](https://api.bilibili.com/x/note/image?image_id=412542)


![https://api.bilibili.com/x/note/image?image_id=412544](https://api.bilibili.com/x/note/image?image_id=412544)
第三点：比如返回父类和子类
![https://api.bilibili.com/x/note/image?image_id=412545](https://api.bilibili.com/x/note/image?image_id=412545)
---
构造方法
![https://api.bilibili.com/x/note/image?image_id=412546](https://api.bilibili.com/x/note/image?image_id=412546)
这就是为什么在有参构造后，还要手动写一个空参。因为为了将来的子类继承它时，不会因为默认super()而出错。
![https://api.bilibili.com/x/note/image?image_id=412548](https://api.bilibili.com/x/note/image?image_id=412548)
this构造方法调用本类构造方法；默认的super()
![https://api.bilibili.com/x/note/image?image_id=412551](https://api.bilibili.com/x/note/image?image_id=412551)
---
多态
![https://api.bilibili.com/x/note/image?image_id=412552](https://api.bilibili.com/x/note/image?image_id=412552)


![https://api.bilibili.com/x/note/image?image_id=412553](https://api.bilibili.com/x/note/image?image_id=412553)


![https://api.bilibili.com/x/note/image?image_id=412554](https://api.bilibili.com/x/note/image?image_id=412554)
 
![https://api.bilibili.com/x/note/image?image_id=412555](https://api.bilibili.com/x/note/image?image_id=412555)


![https://api.bilibili.com/x/note/image?image_id=412557](https://api.bilibili.com/x/note/image?image_id=412557)


![https://api.bilibili.com/x/note/image?image_id=412556](https://api.bilibili.com/x/note/image?image_id=412556)


![https://api.bilibili.com/x/note/image?image_id=412558](https://api.bilibili.com/x/note/image?image_id=412558)


![https://api.bilibili.com/x/note/image?image_id=412581](https://api.bilibili.com/x/note/image?image_id=412581)
此外，还可以调用子类继承但没重写的父类的成员方法。
【内存图】
[🚩面向对象进阶-10-多态中调用成员... P130 - 10:25](https://www.bilibili.com/video/BV17F411T7Ao?p=130&t=624)
先加载父类的字节码文件，再加载子类的。同时虚方法表也是如此顺序向下传递。
![https://api.bilibili.com/x/note/image?image_id=412582](https://api.bilibili.com/x/note/image?image_id=412582)
---
多态的弊端：
![https://api.bilibili.com/x/note/image?image_id=412584](https://api.bilibili.com/x/note/image?image_id=412584)
![https://api.bilibili.com/x/note/image?image_id=412586](https://api.bilibili.com/x/note/image?image_id=412586)
JDK14的新特性：
![https://api.bilibili.com/x/note/image?image_id=412588](https://api.bilibili.com/x/note/image?image_id=412588)


![https://api.bilibili.com/x/note/image?image_id=412589](https://api.bilibili.com/x/note/image?image_id=412589)
----
包
![https://api.bilibili.com/x/note/image?image_id=412590](https://api.bilibili.com/x/note/image?image_id=412590)
import 冲突
![https://api.bilibili.com/x/note/image?image_id=412592](https://api.bilibili.com/x/note/image?image_id=412592)
只导一个：
![https://api.bilibili.com/x/note/image?image_id=412593](https://api.bilibili.com/x/note/image?image_id=412593)
建议：都用全类名。
![https://api.bilibili.com/x/note/image?image_id=412591](https://api.bilibili.com/x/note/image?image_id=412591)


![https://api.bilibili.com/x/note/image?image_id=412594](https://api.bilibili.com/x/note/image?image_id=412594)
---
final
![https://api.bilibili.com/x/note/image?image_id=412604](https://api.bilibili.com/x/note/image?image_id=412604)


![https://api.bilibili.com/x/note/image?image_id=412599](https://api.bilibili.com/x/note/image?image_id=412599)


![https://api.bilibili.com/x/note/image?image_id=412600](https://api.bilibili.com/x/note/image?image_id=412600)
 String为什么不可改变？因为final固定字节数组value，而且private声明是私有，且没有提供setter方法。
![https://api.bilibili.com/x/note/image?image_id=412602](https://api.bilibili.com/x/note/image?image_id=412602)
---
权限修饰符：
![https://api.bilibili.com/x/note/image?image_id=412607](https://api.bilibili.com/x/note/image?image_id=412607)


![https://api.bilibili.com/x/note/image?image_id=412608](https://api.bilibili.com/x/note/image?image_id=412608)
---
代码块：局部代码块、构造代码块、静态代码块。
局部代码块：用完之后立马回收，节省内存。
![https://api.bilibili.com/x/note/image?image_id=412612](https://api.bilibili.com/x/note/image?image_id=412612)


构造代码块：抽出构造方法中重复的部分。
每次创建对象时，优先于构造方法执行。
![https://api.bilibili.com/x/note/image?image_id=412615](https://api.bilibili.com/x/note/image?image_id=412615)


![https://api.bilibili.com/x/note/image?image_id=412614](https://api.bilibili.com/x/note/image?image_id=412614)
 
![https://api.bilibili.com/x/note/image?image_id=412617](https://api.bilibili.com/x/note/image?image_id=412617)
被取代：
![https://api.bilibili.com/x/note/image?image_id=412619](https://api.bilibili.com/x/note/image?image_id=412619)
静态代码块：只能使用静态变量。
![https://api.bilibili.com/x/note/image?image_id=412620](https://api.bilibili.com/x/note/image?image_id=412620)


![https://api.bilibili.com/x/note/image?image_id=412621](https://api.bilibili.com/x/note/image?image_id=412621)


![https://api.bilibili.com/x/note/image?image_id=412623](https://api.bilibili.com/x/note/image?image_id=412623)


![https://api.bilibili.com/x/note/image?image_id=412624](https://api.bilibili.com/x/note/image?image_id=412624)
----
抽象类
![https://api.bilibili.com/x/note/image?image_id=412627](https://api.bilibili.com/x/note/image?image_id=412627)


![https://api.bilibili.com/x/note/image?image_id=412628](https://api.bilibili.com/x/note/image?image_id=412628)
抽象类的构造方法，是给子类创建对象时，通过父类的构造方法super赋值（私有）成员变量的。
![https://api.bilibili.com/x/note/image?image_id=412630](https://api.bilibili.com/x/note/image?image_id=412630)


----
接口
![https://api.bilibili.com/x/note/image?image_id=412635](https://api.bilibili.com/x/note/image?image_id=412635)


![https://api.bilibili.com/x/note/image?image_id=412638](https://api.bilibili.com/x/note/image?image_id=412638)


![https://api.bilibili.com/x/note/image?image_id=412675](https://api.bilibili.com/x/note/image?image_id=412675)


![https://api.bilibili.com/x/note/image?image_id=412685](https://api.bilibili.com/x/note/image?image_id=412685)


![https://api.bilibili.com/x/note/image?image_id=412686](https://api.bilibili.com/x/note/image?image_id=412686)
---
接口新特性：
JDK8，默认方法、静态方法
JDK9，私有方法


默认方法
![https://api.bilibili.com/x/note/image?image_id=412691](https://api.bilibili.com/x/note/image?image_id=412691)


![https://api.bilibili.com/x/note/image?image_id=412692](https://api.bilibili.com/x/note/image?image_id=412692)
静态方法：不是重写，因为不在虚方法表中。
![https://api.bilibili.com/x/note/image?image_id=412693](https://api.bilibili.com/x/note/image?image_id=412693)


