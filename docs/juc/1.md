## 介绍下公平锁和非公平锁

- 公平锁：按照多个线程的申请锁的顺序来获取锁。
- 非公平锁：不按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。在高并发环境下，有可能造成优先级反转、饥饿的状态

PS：默认非公平锁、适用场景

## 为什么会有公平锁/非公平锁的设计？为什么默认非公平锁

- 线程切换有开销。
    
    采用公平锁自然会在多个不同的线程之间切换，而采用非公平锁，很可能是同一个线程释放锁再获取锁，从而减少了线程切换的开销。

- 充分地利用CPU的时间片

    同时，恢复挂起的线程到真正锁的获取存在时间差，非公平锁能更充分地利用CPU的时间片，尽量减少CPU空间状态时间。

## 什么时候用公平？什么时候用非公平？

- 为了更高的吞吐量，选择非公平锁。因为节省了很多线程切换的时间，吞吐量自然就上去了
- 为了防止优先级反转、饥饿，选择公平锁。

## 可重入锁是什么

同一线程在外层获取到锁后，在内层仍然可以获取锁，并不会因为外层获取而不释放锁而陷入死锁。可重复、可递归调用

同一线程中的多个流程可以获取同一把锁，持有这把同步锁可以再次进入，自己可以获取自己的内部锁。

## 有哪些可重入锁

- 隐式锁：synchronized修饰的方法或者代码块
- 显式锁（即Lock）：ReentrantLock

## 可重入锁的重入原理

每个锁对象`ObjectMonitor`拥有一个指向该锁的线程的指针`_owner`、一个锁计数器`_count`、一个锁重入次数`_recursions`。

当执行monitorenter加锁指令时，根据**锁计数器**判断锁对象是否被线程占用。
- 如果锁计数器为0，则直接占用，JVM会将锁对象的持有线程设为当前线程，执行加锁操作（计数器+1，锁重入次数+1）.
- 如果锁计数器不为0，那么就要判断持有线程是不是当前线程。如果是，执行加锁操作；如果不是，那么将当前线程放入阻塞队列，等待至锁被释放。
  
当执行monitorexit解锁指令时，执行解锁操作（锁计数器-1、锁重入次数-1），并根据锁重入次数判断当前线程是否被释放：
- 如果锁重入次数为0，则说明从多层重入中全部退出，置空`_onwer`，释放锁。
- 如果锁重入次数不为0，则说明还处于多层重入中，继续持有锁对象。


synchronized锁会自动获取释放锁，而ReentrantLock锁则需要注意释放`lock.unlock()`，否则其他线程无法获取到该锁。

![alt text](../../images/image-66.png)

PS：为什么需要一个锁计数器`_count`、一个锁重入次数`_recursions`？ReentrantLock锁则需要注意释放`lock.unlock()`，否则锁重入次数不为0，还是锁的计数器不为0？

## 死锁

死锁是指两个或两个以上的线程在执行过程中，因抢夺资源而造成的一种**互相等待**的现象，若无外力干涉，则它们无法再继续推进下去。

产生原因：
- 系统资源不足
- 进程运行推进顺序不合适 
- 系统资源分配不当

怎么排查：
- jstack: `jps -l`获进程号，`jstack 进程号`
- jconsole

## 乐观锁和悲观锁之间的区别

## 乐观锁和悲观锁的适用场景

乐观锁读多，悲观锁写多