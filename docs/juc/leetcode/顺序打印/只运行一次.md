# 自旋派：单个

## volatile int + 自旋

每个count值对应一个方法

​	volatile 修饰的 int 

​	自旋

​		`while(count!=target)`的空转

​		前一个执行完会`count++`

```java
// 1114. 按序打印
class Foo {
    volatile int count=0;

    public Foo() {
        
    }

    public void first(Runnable printFirst) throws InterruptedException {
        printFirst.run();
        count++;
    }

    public void second(Runnable printSecond) throws InterruptedException {
        while (count!=1);
        printSecond.run();
        count++;
    }

    public void third(Runnable printThird) throws InterruptedException {
        while (count!=2);
        printThird.run();
    }
}
```

## AtomicInteger

相当于包装了下volatile int

```java
class Foo {
    AtomicInteger count = new AtomicInteger(0);

    public Foo() {

    }

    public void first(Runnable printFirst) throws InterruptedException {
        printFirst.run();
        count.incrementAndGet();
    }

    public void second(Runnable printSecond) throws InterruptedException {
        while(count.get() != 1);
        printSecond.run();
        count.incrementAndGet();
    }

    public void third(Runnable printThird) throws InterruptedException {
        while(count.get() != 2);
        printThird.run();
    }
}
```

# 自旋派：多个

## volatile int + 自旋

A方法控制B的count。

```java
// 1114. 按序打印
class Foo {
    volatile int count1 = 0;
    volatile int count2 = 0;

    public Foo() {

    }

    public void first(Runnable printFirst) throws InterruptedException {
        printFirst.run();
        count1++;
    }

    public void second(Runnable printSecond) throws InterruptedException {
        while (count1 != 1);
        printSecond.run();
        count2++;
    }

    public void third(Runnable printThird) throws InterruptedException {
        while (count2 != 1);
        printThird.run();
    }
}
```

## AtomicInteger

```java
class Foo {
    AtomicInteger firstDone = new AtomicInteger(0);
    AtomicInteger secondDone = new AtomicInteger(0);

    public Foo() {

    }

    public void first(Runnable printFirst) throws InterruptedException {
        printFirst.run();
        firstDone.incrementAndGet();
    }

    public void second(Runnable printSecond) throws InterruptedException {
        while(firstDone.get() != 1);
        printSecond.run();
        secondDone.incrementAndGet();
    }

    public void third(Runnable printThird) throws InterruptedException {
        while(secondDone.get() != 1);
        printThird.run();
    }
}
```



# 阻塞派：单个

## synchronized + wait notify

wait有点东西，使用flag来控制睡眠条件，选择while而不是if是因为first会唤醒所有，就可能被唤醒多次。



PS：为什么flag不需要 volatile

```java
// synchronized object 
class Foo {
    boolean firstDone = false;
    boolean secondDone = false;
    Object object = new Object();

    public Foo() {

    }

    public void first(Runnable printFirst) throws InterruptedException {
        synchronized (object) {
            printFirst.run();
            firstDone = true;
            object.notifyAll();
        }
    }

    public void second(Runnable printSecond) throws InterruptedException {
        synchronized (object) {
            while (!firstDone) {
                object.wait();
            }
            printSecond.run();
            secondDone = true;
            object.notifyAll();
        }
    }

    public void third(Runnable printThird) throws InterruptedException {
        synchronized (object) {
            while (!secondDone) {
                object.wait();
            }
            printThird.run();
        }
    }
}
```

```java
// synchronized method
class Foo {
    boolean firstDone = false;
    boolean secondDone = false;

    public Foo() {

    }

    public synchronized void first(Runnable printFirst) throws InterruptedException {
        printFirst.run();
        firstDone = true;
        notifyAll();
    }

    public synchronized void second(Runnable printSecond) throws InterruptedException {
        while (!firstDone) {
            wait();
        }
        printSecond.run();
        secondDone = true;
        notifyAll();
    }

    public synchronized void third(Runnable printThird) throws InterruptedException {
        while (!secondDone) {
            wait();
        }
        printThird.run();
    }
}
```

# 阻塞派：多个

## Semaphore

Semaphore是acquire消耗1个，release增加1个。

```java
class Foo {
    Semaphore s2 = new Semaphore(0);
    Semaphore s3 = new Semaphore(0);

    public Foo() {

    }

    public void first(Runnable printFirst) throws InterruptedException {
        printFirst.run();
        s2.release();
    }

    public void second(Runnable printSecond) throws InterruptedException {
        s2.acquire();
        printSecond.run();
        s3.release();
    }

    public void third(Runnable printThird) throws InterruptedException {
        s3.acquire();
        printThird.run();
    }
}
```

## CountDownLatch

CountDownLatch是等待为0才执行。

```java
class Foo {
    CountDownLatch latch1 = new CountDownLatch(1);
    CountDownLatch latch2 = new CountDownLatch(1);

    public Foo() {

    }

    public void first(Runnable printFirst) throws InterruptedException {
        printFirst.run();
        latch1.countDown();
    }

    public void second(Runnable printSecond) throws InterruptedException {
        latch1.await();
        printSecond.run();
        latch2.countDown();
    }

    public void third(Runnable printThird) throws InterruptedException {
        latch2.await();
        printThird.run();
    }
}
```

