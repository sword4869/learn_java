自旋派均超时！！！！



# 自旋派：单个

## volatile int + 自旋

通过取余来控制，不同的余数对应不同的方法

```java
// 1115. 交替打印 FooBar
class FooBar {
    private int n;
    volatile int count = 0;

    public FooBar(int n) {
        this.n = n;
    }

    public void foo(Runnable printFoo) throws InterruptedException {
        for (int i = 0; i < n; i++) {
            while(count % 2 != 0);            
        	printFoo.run();
            count++;
        }
    }

    public void bar(Runnable printBar) throws InterruptedException {
        for (int i = 0; i < n; i++) {
            while(count % 2 != 1);            
        	printBar.run();
            count++;
        }
    }
}
```

## AtomicInteger

相当于包装了下volatile int

```java
class FooBar {
    private int n;
    AtomicInteger count = new AtomicInteger(0);

    public FooBar(int n) {
        this.n = n;
    }

    public void foo(Runnable printFoo) throws InterruptedException {
        for (int i = 0; i < n; i++) {
            while (count.get() % 2 != 0);
            printFoo.run();
            count.incrementAndGet();
        }
    }

    public void bar(Runnable printBar) throws InterruptedException {
        for (int i = 0; i < n; i++) {
            while (count.get() % 2 != 1);
            printBar.run();
            count.incrementAndGet();
        }
    }
}
```



# 自旋派：多个

## volatile int + 自旋

互相控制：

​	A方法控制B的count，B方法控制A的count。

顺序：

​	count的初值相同，但跳出while空转的起始阈值不同。

```java
// 1115. 交替打印 FooBar
class FooBar {
    private int n;
    volatile int count1 = 0;
    volatile int count2 = 0;

    public FooBar(int n) {
        this.n = n;
    }

    public void foo(Runnable printFoo) throws InterruptedException {
        for (int i = 0; i < n; i++) {
            while (count1 != i);
            printFoo.run();
            count2++;
        }
    }

    public void bar(Runnable printBar) throws InterruptedException {
        for (int i = 0; i < n; i++) {
            // i+1
            while (count2 != i+1);
            printBar.run();
            count1++;
        }
    }
}
```

## AtomicInteger

```java
class Foo {
    AtomicInteger firstDone = new AtomicInteger(0);
    AtomicInteger secondDone = new AtomicInteger(0);

    public Foo() {

    }

    public void first(Runnable printFirst) throws InterruptedException {
        printFirst.run();
        firstDone.incrementAndGet();
    }

    public void second(Runnable printSecond) throws InterruptedException {
        while(firstDone.get() != 1);
        printSecond.run();
        secondDone.incrementAndGet();
    }

    public void third(Runnable printThird) throws InterruptedException {
        while(secondDone.get() != 1);
        printThird.run();
    }
}
```

# 阻塞派：单个

## synchronized + wait notify

交替：

​	检测时，检测上一个flag是否完成。

​	执行时，下一个flagDone完成，并且上一个flag归零。

```java
class FooBar {
    private int n;
    boolean firstDone = false;
    boolean secondDone = false;
    Object object = new Object();

    public FooBar(int n) {
        this.n = n;
    }

    public void foo(Runnable printFoo) throws InterruptedException {
        for (int i = 0; i < n; i++) {
            synchronized (object) {
                while (i != 0 && !secondDone) {
                    object.wait();
                }
                printFoo.run();
                firstDone = true;
                secondDone = false;
                object.notify();
            }
        }
    }

    public void bar(Runnable printBar) throws InterruptedException {
        for (int i = 0; i < n; i++) {
            synchronized (object) {
                while (!firstDone) {
                    object.wait();
                }
                printBar.run();
                secondDone = true;
                firstDone = false;
                object.notify();
            }
        }
    }
}
```



