

## 1. 你谈谈 JMM（Java 内存模型） 

JMM(Java Memory Model) Java内存模型。

Java内存模型，是一种抽象概念，描述了java虚拟机中所规范的内存模型。

作用：
- 通过JMM来实现线程和主内存之间的抽象关系。
- 屏蔽各个硬件平台和操作系统的内存访问差异，来实现让Java程序再各种平台下都能达到一致性的内存访问效果。


规范：

1. 所有的**共享变量**都存储于主内存。**共享变量即实例变量和类变量**，不包含局部变量，因为局部变量是线程私有的，因此不存在竞争问题。

2. 每一个线程有私有的**工作内存**，保留了被线程使用的变量的工作副本。
3. 线程对变量的所有的操作(读，写)都必须在工作内存中完成，而不能直接读写主内存中的变量。
4. 不同线程之间也不能直接访问对方工作内存中的变量，线程间变量的值的传递需要通过主内存完成。

![](https://cdn.jsdelivr.net/gh/sword4869/pic1@main/images/202407112140956.png)


## 2. 导致并发程序的问题原因(Java并发编程/JMM/线程安全的三大特性)

原子性、可见性和有序性。

- 原子性：指一个操作是不可被打断的，即多线程环境下，操作不能被其他线程干扰
- 可见性：当一个线程修改了某一个共享变量的值，其他线程对此修改可见。
- 有序性（禁重排）：为了提升性能，**编译器和处理器**通常会对指令序列进行重新排序。重排序后的指令不能改变原有的串行语义。不存在数据依赖关系，可以重排序；存在数据依赖关系，禁止重排序。

## 3. 那该如何保证Java程序在多线程的情况下执行安全呢？

- 原子性: 加锁 synchronized/Lock、AtomicXxx原子类

- 可见性: 加锁 synchronized/Lock，或者 volatile

- 有序性: volatile

## 4. 内存屏障
volatile实现了JMM中的可见性和有序性，但无法保证原子性（还需要锁）。

可见性和有序性是通过内存屏障保证。

> 可见性

写 `|` 内存屏障 `|` 读：
- volatile的写内存语义是写完后立即刷新回主内存，读的内存语义是直接从主内存中读取。
- 内存屏障之前的所有写操作都要回写到主内存
- 内存屏障之后的所有读操作都能获得内存屏障之前的所有写操作的最新结果（实现了可见性）

写屏障（Store Barrier）：（约束过去）写屏障之前的写操作，将所有在缓冲中的数据刷回到主内存中。

读屏障(Load Memory Barrier)：（约束将来）读屏障之后的读操作，会让工作内存或CPU高速缓存当中的缓存数据失效，需要重新回到主内存中获取最新数据。这样保证读屏障后面的读操作一定能够读取到最新的数据。

> 重排序

写内存屏障 `|` volatile变量 `|` 读内存屏障（volatile变量读之上有**写屏障**，之下有**读屏障**）：
- 不允许把内存屏障之后的指令重排序到内存屏障之前
- 写操作加的屏障是阻止上方其它写操作越过屏障排到volatile变量写之下
- 读操作加的屏障是阻止下方其它读操作越过屏障排到volatile变量读之上

![](https://cdn.jsdelivr.net/gh/sword4869/pic1@main/images/202407112140957.png)

```java
public class Reorder {
    int x;
    int y;

    @Actor
    public void actor1() {
        x = 1;
        y = 1;
    }

    @Actor
    public void actor2(II_Result r) {
        r.r1 = y;
        r.r2 = x;
    }
}
```
在去获取上面的结果的时候，有可能会出现4种情况

情况一：先执行actor2获取结果--->0,0(正常)

情况二：先执行actor1中的第一行代码，然后执行actor2获取结果--->0,1(正常)

情况三：先执行actor1中所有代码，然后执行actor2获取结果--->1,1(正常)

情况四：先执行actor1中第二行代码，然后执行actor2获取结果--->1,0(发生了指令重排序，影响结果)

**解决方案**

在变量上添加volatile，禁止指令重排序，则可以解决问题

![](https://cdn.jsdelivr.net/gh/sword4869/pic1@main/images/202407112140958.png)

屏障添加的示意图

![](https://cdn.jsdelivr.net/gh/sword4869/pic1@main/images/202407112140957.png)

- 写操作加的屏障是阻止上方其它写操作越过屏障排到volatile变量写之下
- 读操作加的屏障是阻止下方其它读操作越过屏障排到volatile变量读之上

**其他补充**

我们上面的解决方案是把volatile加在了int y这个变量上，我们能不能把它加在int x这个变量上呢？

下面代码使用volatile修饰了x变量

![](https://cdn.jsdelivr.net/gh/sword4869/pic1@main/images/202407112140959.png)

屏障添加的示意图

![](https://cdn.jsdelivr.net/gh/sword4869/pic1@main/images/202407112140960.png)

这样显然是不行的，主要是因为下面两个原则：


所以，现在我们就可以总结一个volatile使用的小妙招：

- 写变量让volatile修饰的变量的在代码最后位置
- 读变量让volatile修饰的变量的在代码最开始位置
