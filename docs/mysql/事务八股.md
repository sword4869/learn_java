## 事务会不会自动提交?

MySQL 默认开启事务自动提交模式，即除非显式的开启事务（BEGIN 或 START TRANSACTION），否则每条 SOL 语句都会被当做一个单独的事务自动执行。

要启用自动提交，在执行任何DML（Data Manipulation Language）语句（例如INSERT、UPDATE、DELETE）之前，可以使用以下语句开启自动提交：

```
SET autocommit = 1;
```

或者可以在连接到数据库时在连接字符串中指定`autocommit`参数为1。

```
mysql -u username -p -h hostname dbname --autocommit=1
```

这将使得MySQL会话处于自动提交模式，这意味着每个单独的DML语句都将自动成为一个事务，并在执行完成后立即提交。

如果想要禁用自动提交，可以使用以下语句：

```
SET autocommit = 0;
```

或者在连接字符串中指定`autocommit`参数为0。

## 事务的ACID

- 原子性（Atomicity）：事务中的所有操作，要么全部成功，要么全部失败回滚。
- 一致性（Consistency）：事务执行前后，数据库都应该保持一致性状态。
- 隔离性（Isolation）：多个并发的事务之间应该互相隔离，避免互相干扰。
- 持久性（Durability）：事务提交后，对数据库的修改应该永久保存，即使系统故障也不应该丢失。

PS：一致性：数据库内部的**完整性**约束、声明性约束。转账，两用户总金额不变。

## 原子性、一致性、隔离性和持久性他们分别是有什么作用？

- 原子性：保证（事务中所有操作要么全部成功，要么全部失败回滚），避免因为部分操作失败导致数据不一致或错误的结果。
- 一致性：保证（事务执行前后，数据库都应该保持一致性状态），避免数据的不一致性。
- 隔离性：保证（多个并发的事务之间应该互相隔离，避免互相干扰），避免读取到未提交的数据或者脏数据，避免并发操作导致的数据冲突。
- 持久性：保证（事务提交后，对数据库的修改应该永久保存，即使系统故障也不应该丢失），避免数据的丢失和不可恢复。

## 事务并发的三种并发问题？脏读、不可重复读、幻读

脏读、幻读和不可重复读是数据库中的三种并发问题：

-   脏读（Dirty Read）：指一个事务读取了另一个事务未提交的数据，如果另一个事务回滚，则读取的数据是无效的。
-   幻读（Phantom Read）：指一个事务执行了两次查询，第二次查询发现了第一次查询没有发现的新数据或者没有查询到第一次查询中存在的数据。
-   不可重复读（Non-Repeatable Read）：指一个事务执行两次查询，第二次查询读取到了第一次查询中未提交的数据或另一个事务提交的数据。

这些问题的出现是由于多个事务同时访问数据库，而缺乏一定的隔离性和同步机制。为了解决这些问题，可以采用不同的隔离级别和锁机制来保证数据的一致性和可靠性。

## 事务的隔离级别有哪几种，作用分别是？

数据库事务的隔离级别有四种，分别为读未提交（Read Uncommitted）、读已提交（Read Committed）、可重复读（Repeatable Read）和串行化（Serializable）。

-   读未提交：最低的隔离级别，允许一个事务读取另一个事务未提交的数据。这种隔离级别会导致脏读、不可重复读和幻读问题。
-   读已提交：允许一个事务读取另一个事务已提交的数据，避免了脏读问题。但是仍然可能存在不可重复读和幻读问题。
-   可重复读：保证一个事务多次读取同一数据时，能够得到相同的结果，避免了不可重复读问题。但是仍然可能存在幻读问题。
-   串行化：最高的隔离级别，强制事务串行执行，避免了所有并发问题，但是会导致性能下降。

选择合适的隔离级别取决于应用场景和性能要求。通常情况下，可重复读,能够在保证数据一致性的同时兼顾性能，这也是mysql默认的隔离级别。

## MySQL默认的隔离级别是什么?

MySQL的默认隔离级别是可重复读（Repeatable Read）。在可重复读隔离级别下，事务可以读取其他事务已经提交的数据，但是不会看到其他事务未提交的数据。这意味着在同一个事务中多次读取相同的数据，将会得到相同的结果，即使其他事务对该数据进行了修改也是如此。

可重复读隔离级别保证了在同一个事务中多次读取数据时的一致性，但也可能导致一些并发问题，如幻读（Phantom Read）。MySQL提供了其他隔离级别来解决不同的并发问题，包括读未提交（Read Uncommitted）、读已提交（Read Committed）和串行化（Serializable）等。

需要注意的是，虽然MySQL的默认隔离级别是可重复读，但实际上可以在会话级别或全局级别进行更改，以满足特定的应用需求。

InnoDB 当前读下的幻读是通过间隙锁（gap_lock)来实现的。在事务A查询的时候，会锁住一个间隙，其它事务往这个间隙插入、删除等操作都是会被锁阻塞的。间隙锁和插入意向锁互斥，彻底解决了当前读下的幻读问题。

但是InnoDB 没有完全解决快照读下的幻读问题。