- [1. 性能优化](#1-性能优化)
  - [1.1. 插入](#11-插入)
  - [1.2. group by](#12-group-by)
  - [1.3. order by优化](#13-order-by优化)
  - [1.4. limit优化](#14-limit优化)
  - [count优化](#count优化)
- [2. 列分离](#2-列分离)


---
## 1. 性能优化

不建议使用`select *`, 而是全部罗列出来。

### 1.1. 插入

批量插入数据 `insert into tb_test values(7,'Tom'),(8,'Cat'),(9,'Jerry');`

load指令进行插入几百万的记录

手动控制事务

主键顺序插入，性能要高于乱序插入。因为页分裂（移动+调序）
- 可以使用AUTO_INCREMENT自增主键。
- 尽量不要使用UUID做主键或者是其他自然主键，如身份证号。

### 1.2. group by

A. 在分组操作时，可以通过索引来提高效率。
B. 分组操作时，索引的使用也是满足最左前缀法则的。

### 1.3. order by优化

MySQL的排序，有两种方式：Using filesort 和 Using index

- Using index的性能高。通过有序索引顺序扫描直接返回有序数据，不需要额外排序。

- Using filesort : 通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区sort
buffer中完成排序操作。

idx_phone_age: 都素升序的联合索引
- 根据age, phone进行降序排序。支持，因为反向扫描。
- 根据phone，age进行升序排序，phone在前，age在后。否则就会出现 Using
filesort
- 根据age, phone进行降序一个升序，一个降序，是Using filesort。


出order by优化原则:
A. 根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则。
B. 尽量使用覆盖索引。
C. 多字段排序, 一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC/DESC）。
D. 如果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小sort_buffer_size(默认256k)。

### 1.4. limit优化
在查询时，越往后，分页查询效率越低。排序前2000010 记录，返回 2000000 - 2000010 的记录，其他记录丢弃。

优化：覆盖索引+子查询

```sql
-- 不支持，因为()出现了Limit
-- select * from tb_sku t where id in (select id from tb_sku order by id limit 2000000,10);


explain select * from tb_sku t , (select id from tb_sku order by id limit 2000000,10) a where t.id = a.id;
```

### count优化




## 2. 列分离

商品表，商品描述（不常动的）和商品库存（频繁修改的）分离，同一个商品id作为主键。缓存，不然修改库存，缓存就失效了。


---


查询SQL的执行频次，我们就能够知道当前数据库到底是增删改为主，还是查询为主

`SHOW GLOBAL STATUS LIKE 'Com_______';`

慢查询日志，定位出执行效率比较低的SQL，从而有针对性的进行优

show profiles。每一条SQL的耗时；指定SQL语句的各个阶段耗时、CPU使用。


explain或desc命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行
过程中表如何连接和连接的顺序。

SQL提示：建议使用某索引（还会评估）；忽略某索引；强制使用某索引


覆盖索引：查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到。如查id和name，name是索引，直接走二级索引返回数据。如查id和name和age，针对于 name和age建立联合索引。


