
## Java 中有哪几块内存需要进行垃圾回收

线程不共享的程序计数器、虚拟机栈、本地方法栈，跟随线程的生命周期随着线程回收而回收，不需要进行垃圾回收。

线程共享的堆和方法区有垃圾回收：
- 堆：垃圾回收器会自动回收不再被引用的对象，释放内存空间。
- 方法区：【一般不需要回收，JSP 等技术才会通过回收类加载器去回收方法区中的类】【主要针对无用的类和常量进行回收】

不同的垃圾回收器有不同的工作方式和策略，它们会根据具体的配置和场景来决定何时进行垃圾回收以及如何回收

## 有哪几种常见的引用类型？

- 强引用，最常见的引用方式，由可达性分析算法来判断
- 软引用，对象在没有强引用情况下，内存不足时会回收。场景，高速缓存、读取大量图片。
- 弱引用，对象在没有强引用情况下，会直接回收
- 虚引用，通过虚引用知道对象被回收了。场景，直接内存
- 终结器引用，对象回收时可以自救，不建议使用

## 有哪几种常见的垃圾回收算法？

- 标记-清除算法：标记之后再清除，容易产生内存碎片
- 复制算法：从一块区域复制到另一块区域，容易造成只能使用一部分
- 标记-整理算法：标记之后将存活的对象推到一边，移动对象，效率最低
- 分代GC算法：将内存区域划分成年轻代、幸存者区、老年代进行回收，可以使用多种回收算法

-   **标记-清除算法（Mark and Sweep）**：
    
    -   标记阶段：从根对象出发，递归地标记所有可以被访问到的对象。
    -   清除阶段：清除未被标记的对象，即不可达对象。
    -   缺点：产生内存碎片，可能导致内存分配效率降低。
-   **复制算法（Copying）**：
    
    -   将堆内存分为两个区域：年轻代和老年代。
    -   年轻代分为Eden区和两个Survivor区。
    -   对象首先被分配到Eden区，当Eden区满时，触发Minor GC，将存活的对象复制到Survivor区，然后清空Eden区和一个Survivor区，再将存活的对象从另一个Survivor区复制到空的Survivor区。
    -   优点：不会产生内存碎片，适用于频繁回收对象的场景。
-   **标记-整理算法（Mark and Compact）**：
    
    -   标记阶段：与标记-清除算法相同，标记所有可达对象。
    -   整理阶段：将所有存活的对象向一端移动，然后清理掉不可达对象，从而消除内存碎片。
    -   优点：不会产生内存碎片，可以提高内存分配效率。
-   **分代收集算法（Generational Collection）**：
    
    -   将堆内存分为年轻代和老年代两部分，使用不同的GC算法。
    -   年轻代通常使用复制算法，因为大多数对象在这里很快变得不可达，适合频繁进行垃圾收集。
    -   老年代通常使用标记-清除或标记-整理算法，因为老年代存活的对象较多，适合采用更加成熟的算法来进行垃圾收集。
-   **G1算法（Garbage-First）**：
    
    -   将堆内存分成多个大小相等的区域（Region），包括年轻代、老年代和Metaspace等。
    -   将整个堆内存划分为多个Region，通过标记-复制和标记-整理的方式来执行垃圾收集。
    -   G1算法通过优先收集垃圾最多的Region来提高垃圾收集效率，因此称为“Garbage-First”。

## 常见的垃圾回收器有哪些？

- Serial和Serial Old：单线程回收，主要适用于单核CPU场景
- ParNew和CMS：暂停时间较短，适用于大型互联网应用中与用户交互的部分
- Parallel Scavenge和Parallel Old：吞吐量高，适用于后台进行大量数据操作
- G1：适用于较大的堆，具有可控的暂停时间

## G1 垃圾回收器了解吗?
G1（Garbage-First）垃圾回收器是Java虚拟机（JVM）中一种现代的垃圾回收器，引入自Java 7 Update 4版本。G1垃圾回收器旨在替代CMS（Concurrent Mark-Sweep）垃圾回收器，并且在大内存堆上表现更加稳定和高效。

G1垃圾回收器具有以下特点：

1.  **区域化内存管理**：G1将堆内存划分为多个固定大小的区域（Region），每个区域可以是Eden区、Survivor区或Old区。这种区域化的内存管理有助于更好地控制垃圾回收过程，减少停顿时间。
    
2.  **分代收集**：虽然G1并不是一个传统的分代收集器，但它仍然将堆内存划分为年轻代和老年代，并且使用不同的垃圾回收策略来处理这两个代。
    
3.  **并发标记清除**：G1使用了并发标记（Concurrent Marking）来减少垃圾回收暂停时间。在标记阶段，G1通过并发标记线程来标记活动对象，而在应用程序运行的同时，也会继续标记操作。这样可以减少标记阶段对应用程序的影响。
    
4.  **整理内存**：G1使用了复制算法来清理内存，不再使用传统的压缩算法。在垃圾收集过程中，G1会选择一些区域进行垃圾收集，并将存活对象复制到其他区域中，从而实现内存的整理和碎片整理。
    
5.  **垃圾优先收集**：G1根据垃圾回收需求来选择优先回收的区域，以此来提高垃圾回收效率。它会优先选择包含垃圾最多的区域进行回收，从而最大程度地减少垃圾对象。
    

G1垃圾回收器在大内存堆上表现更加稳定和高效，尤其适用于需要低停顿时间和更加可控的垃圾回收的应用场景。

## 什么时候会触发 GC?

在Java虚拟机中，垃圾回收（GC）会在以下几种情况下触发：

1.  **系统内存不足**：当Java虚拟机检测到系统内存不足时，会触发垃圾回收来释放内存空间，以确保应用程序的正常运行。这通常是通过监视堆内存的使用情况来检测的。
    
2.  **调用System.gc()方法**：虽然调用System.gc()方法并不会立即触发垃圾回收，但它会向Java虚拟机发出建议性的垃圾回收请求。Java虚拟机可以选择是否立即响应这个请求。
    
3.  **长时间停顿**：当应用程序执行时间较长，而且没有进行垃圾回收时，Java虚拟机可能会为了避免堆内存耗尽而触发垃圾回收。这种情况下，垃圾回收通常会引起一段较长的停顿时间，称为Full GC。
    
4.  **Young Generation满**：在分代垃圾回收器中，当Young Generation区域满时，会触发一次Minor GC。这会导致Eden区和Survivor区的垃圾回收。
    
5.  **Old Generation满**：如果Old Generation区域满了，会触发一次Major GC（也称为Full GC）。这种情况下，整个堆内存都会进行垃圾回收。
    
6.  **永久代/元空间满**：对于HotSpot虚拟机，如果永久代（Java 7之前）或者元空间（Java 8及之后）满了，会触发一次垃圾回收。这种情况下，垃圾回收主要针对类的元数据和常量池。
    

需要注意的是，具体触发垃圾回收的时机和方式取决于Java虚拟机的实现，不同的虚拟机可能有不同的行为。此外，开发人员可以通过调整垃圾回收相关的参数来影响垃圾回收的行为，以优化应用程序的性能和资源利用率。

## System.gc是minor gc还是full gc

full gc


## 调用System.gc后，Java内存会不会马上进行回收

不会，只有在justRanFinalization=true的时候才会执行
