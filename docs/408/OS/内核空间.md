为了保证操作系统的稳定性和安全性，一个进程的地址空间划分为 用户空间（User space） 和 内核空间（Kernel space ） 。

像我们平常运行的应用程序都是运行在用户空间，只有内核空间才能进行**系统态**级别的资源有关的操作，比如文件管理、进程通信、内存管理等等。用户空间的程序不能直接访问内核空间，用户进程想要执行 IO 操作的话，必须通过 **系统调用** 来间接访问内核空间。

我们在平常开发过程中接触最多的就是 磁盘 IO（读写文件） 和 网络 IO（网络请求和响应）。应用程序对操作系统的内核发起 IO 调用（系统调用），操作系统负责的内核执行具体的 IO 操作。

当应用程序发起 I/O 调用后，会经历两个步骤：
- 内核等待 I/O 设备准备好数据
- 内核将数据从内核空间拷贝到用户空间。

## 有哪些常见的 IO 模型?

UNIX 系统下， IO 模型一共有 5 种：同步阻塞 IO、同步非阻塞 IO、IO 多路复用、信号驱动 IO 和异步 IO。

Java 中 3 种常见 IO 模型：
- BIO (Blocking I/O)。同步阻塞 IO 模型 。
- NIO (Non-blocking/New I/O)。IO 多路复用模型。
- AIO (Asynchronous I/O)。异步 IO 模型

### 同步阻塞 IO（BIO）

同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间。

低并发：在客户端连接数量不高的情况下，是没问题的。

### 同步非阻塞IO

同步非阻塞 IO 模型中，应用程序会通过**轮询操作**一直发起 read 调用，等待数据从内核空间拷贝到用户空间。这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。

存在问题：**轮询操作**十分消耗 CPU 资源的。

### IO 多路复用模型(NIO)


IO 多路复用模型，通过减少无效的系统调用，减少了对 CPU 资源的消耗。

IO 多路复用模型中，线程首先发起 select/poll/epoll 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。

### 调用



- 可移植性
    
    几乎所有的操作系统都支持select，在某些Unix系统上并不支持poll，只有Linux操作系统支持epoll（linux 2.6 内核引入）

- 文件描述符的最大数量限制

    select受单个进程/线程可以打开的文件描述符数量限制，默认是1024个文件描述符。

    poll使用链表结构存储文件描述符，没有了select的文件描述符的最大数量限制，但还是有上限。

    epoll更是可以接入成千上万。



- 内存开销

    每次select调用时，文件描述符从用户区拷贝到内核区，遍历所有来检查就绪的文件描述符；select调用结束后，又从内核区拷贝到用户区。

    epoll只需要拷贝进内核区一次。使用一个epoll文件描述符管理多个被监听的文件描述符，将就绪的文件描述符拷贝到内核的就绪事件链表中。

- 时间复杂度

    epoll只会遍历就绪事件链表，而不是像select/poll一样遍历所有的O(n)。



- 内核态检测文件描述符就绪状态的方式：
   
   select、poll采用轮询方式，遍历所有的文件描述符状态是否就绪。而epoll采用回调方式，对文件描述符注册了回调函数，当文件描述符就绪时，会主动调用回调函数来放入就绪事件链表中。

- 其他

    select 对于超时时间提供了更好的精度：微秒，而 poll 和 epoll 都是毫秒级。

    poll相比select，优化编程接口，参数少了。

    select和poll的性能可能比epoll要好，epoll回调开销大。


适用场景：
- select、poll：适合在连接数少并且连接都十分活跃的情况下。
- epoll：适用在连接数很多，活跃连接较少的情况下。

---

JDK4引入。

支持面向缓冲的，基于通道的 I/O 操作方法。

对于高负载、高并发的（网络）应用，应使用 NIO。

Java 中的 NIO ，有一个非常重要的选择器 ( Selector ) 的概念，也可以被称为 多路复用器。通过它，只需要一个线程便可以管理多个客户端连接。当客户端数据到了之后，才会为其服务。

### 异步IO（AIO）

异步 IO 是基于**事件和回调机制**实现的。应用操作之后会直接返回，不会堵塞在那里；当后台处理完成，操作系统会通知相应的线程进行回调。


JDK7引入。