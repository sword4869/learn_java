

# 为什么需要 TIME_WAIT 状态

历史连接

​	防止历史数据阻塞、序列号回绕时的错误历史数据。**足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。**

服务器能*正确的关闭*

​	不等，那么第四次握手丢失，重发FIN后收到客户端的rst。

​	等了，重发FIN后收到的ACK正确关闭。

#  为什么 TIME_WAIT 等待的时间是 2MSL

**MSL 报文最大生存时间**

​	**MSL 应该要大于等于 TTL 消耗为 0 的时间**，以确保报文已被自然消亡

**一来一回需要等待 2 倍的时间**，**2MSL时长**至少允许报文丢失一次

​	如果被动关闭方没有收到断开连接的最后的 ACK 报文，就会触发超时重发 `FIN` 报文，被动方重发的 FIN 会在第 2 个 MSL 内到达， 一来一去正好 2 个 MSL



# 为什么不是 4 或者 8 MSL 的时长呢？

连续两次丢包的概率只有万分之一，这个概率实在是太小了，忽略它比解决它更具性价比。

客户端主动发起断开：无空闲端口时，短时间内无法再次连接相同服务器。

服务器端主动发起断开：只监听一个端口，理论上无影响。但之前的客户端需要换个客户端的端口才能连上。

# 服务器出现大量 TIME_WAIT 状态的原因有哪些

长链接不支持

​	**不管哪一方禁用了 HTTP Keep-Alive，都是由服务端主动关闭连接**。

​	→ 让双方都开启。

长链接满了

​	服务器的 nginx 的 keepalive_requests 控制每个长连接连续处理请求次数限制。高QPS，**nginx 就会很频繁地关闭连接**

​	→ 调大参数。

网络阻塞

​	服务器的 nginx 提供的 keepalive_timeout 控制维持时间，时间到了连接断开。网络问题，导致客户端发送的数据一直没有被服务端接收到

​	→ 检查网络问题。
