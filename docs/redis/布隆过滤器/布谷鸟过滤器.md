# 布谷鸟哈希算法

布谷鸟哈希，使用数组，数组内**存储元素**。

两个hash函数对元素hash，再对数组长度取余，就得到两个下标。

​	如果下标1，不存在元素就放入 → 存在则看下标2，是否空缺 → 都存在，则随机选择踢出原元素，放入新元素。

​	将新元素，重新hash计算放入位置。

# 布谷鸟过滤器

使用数组，数组存的是元素的指纹（8bit），为了减少哈希冲突的影响，数组的每个位置可以存4个指纹。

​	存元素太占空间，故而牺牲一定精确性来存可以代表元素的指纹，由指纹哈希算法得到。

修改hash算法。

​	先计算元素的指纹。

​	哈希函数1直接对元素hash，得到下标1。选择一个空着的指纹位置，存入指纹。

​	哈希函数2对指纹hash，再与下标1异或，得到下标2.

​	这样形成对偶关系。对偶下标 = 下标 ^ 指纹的hash。那么踢出时，拿着原指纹的hash和踢出下标进行异或，得到另一个下标。

​	只要保证 hash(fp) != 0，就能保证 p1 != p2。

```
fp = fingerprint(x)
p1 = hash(x)
p2 = p1 ^ hash(fp)  // 异或
```



删除元素

​	比较下标处的指纹是否和目标指纹一致，一致则删除。

获取元素

​	两处的指纹都一致，则说明不存在。

扩容

​	一个是普通连踢，一直踢，另一个是循环踢，两个元素的两处hash都相同，你踢我，我踢你。

​	当踢的次数达到阈值，扩容。



# 比起布隆，布谷鸟过滤器的优点

支持删除。

比布隆更低的误判。

​	hash算法的设计，同一个位置存储多个指纹的设计。

比布隆更省空间。

​	误判率低了，扩容需求就少了。

# 布谷鸟过滤器的缺点

删除的误判

​	不同元素的指纹相同，导致误删。

删除的次数

​	可以存入相同元素，那么删除一个后还能查出存在，要多次删除。

插入相同元素的上限

​	两处hash，4个指纹，那么最多8个相同元素。

# 布隆过滤器和布谷鸟过滤器的不同

存bit；一个存指纹。

长度无限制；要求2^n。

插入快，直接置1；插入慢，要踢老元素。

不支持删除；支持删除。

 误判、空间大小。



---

[java - 拼夕夕二面：说说布隆过滤器与布谷鸟过滤器？应用场景？我懵了。。 - 个人文章 - SegmentFault 思否](https://segmentfault.com/a/1190000042062606)

[Redis--布谷鸟过滤器--使用/原理/实例_布谷鸟过滤器 redis-CSDN博客](https://blog.csdn.net/feiying0canglang/article/details/121279365)

[布谷鸟过滤器（Cuckoo Filter） - 泰阁尔 - 博客园 (cnblogs.com)](https://www.cnblogs.com/zhaodongge/p/15067657.html)