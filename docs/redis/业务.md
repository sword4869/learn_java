## 全局唯一ID

订单表id自增的问题：
- 订单号容易被猜出来，不安全
- 千万级就要分表，分表后表各自自增，不统一。


全局唯一ID生成策略：
- UUID
- Redis自增策略：符号位0、时间戳31bit、计数器32bit；每天一个key，值就是计数器，方便统计订单量；
- 雪花算法
- 数据库自增表获取自增id。

## 库存超卖

扣库存update时加锁
- 悲观锁：添加同步锁，让线程串行执行
- 乐观锁：不加锁，只在更新时判断是否有其他线程在修改。
    - 版本号法、cas法（融合版本号，判断是否是原值）
    - 解决成功率低：where stock > 0

一人一单：去db查单，但查耗时，会同时判定通过。
- synchronized锁。但在集群下失效，不同JVM内部的常量池让锁失效了。
- 分布式锁。

分布式锁：
- mysql
- zookeeper：节点唯一性和有序性
- redis：基于setnx实现；Redisson。


1）不可重入的Redis分布式锁：set nx ex，存线程UUID，lua脚本判断线程标示并删除
→setnx加锁+del释放。
→expire锁超时释放（解决del前宕机而死锁）
→set lock value ex 10 nx（原子操作，解决expire前宕机）
→锁存线程UUID，del锁判断是否是自己（业务阻塞而锁过期，业务恢复而删除了B业务的锁，让C业务申请到了而和B业务同时执行）
→判断锁标识和释放成为原子性，LUA脚本（判断后阻塞，超时释放，释放锁又释放别人的锁了）

缺陷：不可重入、无法重试、业务耗时久而导致锁超时失效。


2）可重入的Redisson分布式锁：
- 可重入：利用hash结构记录线程id和重入次数。
- 可重试：利用信号量和发布订阅功能实现等待唤醒，获取锁失败的重试机制。
- 超时续约：利用watchdog，每隔一段时间重置超时时间。

缺陷：主从模式下redis主节点宕机引起锁失效。

3）multiLock
- 多个独立的Redis结点
- 去每个节点都获取锁。只有所有节点都获取重入锁，才算取锁成功。

缺陷：运维成本高、实现复杂。

![alt text](../../images/image-128.png)

![alt text](../../images/image-154.png)

![alt text](../../images/image-155.png)

![alt text](../../images/image-156.png)

![alt text](../../images/image-157.png)

![alt text](../../images/image-158.png)

![alt text](../../images/image-159.png)

## 秒杀业务的优化：基于阻塞队列的异步秒杀

将抢单业务和下单业务分离。

1. redis负责判断库存、一人一单，将订单放入阻塞队列。
2. 独立线程异步下单，从阻塞队列中取出，完成数据库操作。

缺陷：
- 内存限制：阻塞队列是基于JDK的BlockQueue，虽然设置了容量上线，但占用JVM总内存。
- 数据安全：宕机丢失、阻塞队列取出后如果出错就无法恢复订单。


## 购物车信息用 String 还是 Hash 存储更好呢?

由于购物车中的商品频繁修改和变动，购物车信息建议使用 Hash 存储：

- 用户 id 为 key
- 商品 id 为 field，商品数量为 value

- 用户添加商品就是往 Hash 里面增加新的 field 与 value；
- 查询购物车信息就是遍历对应的 field；；
- 更改商品数量直接修改对应的 value 值；
- 删除商品就是删除 Hash 中对应的 field；
- 清空购物车直接删除对应的 key 即可。

## 使用 Redis 实现一个排行榜怎么做？

Sorted Set

## 共同好友

set的集合运算。

## 抽奖

set
- `SADD key member1 member2 ...`：向指定集合添加一个或多个元素。
- `SPOP key count`：随机移除并获取指定集合中一个或多个元素，适合不允许重复中奖的场景。
- `SRANDMEMBER key count` : 随机获取指定集合中指定数量的元素，适合允许重复中奖的场景。

## 签到

bitmap：年月作为key，offset是月中31天。

## 统计活跃用户

bitmap：

可以使用日期（精确到天）作为 key，然后用户 ID 为 offset，如果当日活跃过就设置为 1。

## 统计页面 UV 怎么做？

HyperLogLog 

-   `PFADD key element1 element2 ...`：添加一个或多个元素到 HyperLogLog 中。
-   `PFCOUNT key1 key2`：获取一个或者多个 HyperLogLog 的唯一计数。