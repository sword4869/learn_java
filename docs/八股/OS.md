## 为什么要分内核态和用户态

为了保证安全性，内核态的权限高，可以调用系统底层的接口、访问资源。

而用户态权限低，需要一些操作可以切换到内核态下来进行。

## 什么情况会触发到内核态的切换

系统调用（trap）、中断（interrupt）和异常（exception）

## 死锁条件

多个进程因为互相等待对方释放资源而无法继续执行的状态。

死锁发生的条件通常包括以下四个条件：

- 互斥条件（Mutual Exclusion）：至少有一个资源被标记为只能被一个进程占用，即一次只能有一个进程使用该资源。
- 请求与保持条件（Hold and Wait）：一个进程在持有至少一个资源的同时，又请求其他进程占用的资源。
- 不可剥夺条件（No Preemption）：已经分配给一个进程的资源不能被强制性地剥夺，只能由持有该资源的进程主动释放
- 循环等待条件（Circular Wait）：存在一个进程资源的循环链，每个进程都在等待下一个进程所占用的资源。

当这四个条件同时满足时，就可能发生死锁。

## 避免死锁发生的策略

资源预分配、避免循环等待、引入资源剥夺等。

## 线程安全和线程不安全是什么意思?

"线程安全"和"线程不安全"是描述在多线程环境中并发操作的状态的术语。

1.  **线程安全**：
    
    -   线程安全指的是在多线程环境下，对共享数据的访问操作能够保证在并发情况下不会导致数据的不一致性或损坏。一个线程安全的操作或数据结构能够在并发访问时维持其内部状态的一致性。
    -   线程安全的实现通常会采用同步机制（例如锁、信号量等）来保护共享资源的访问，以确保在任意时刻只有一个线程能够访问共享资源，从而避免竞态条件（Race Condition）和其他并发问题。
2.  **线程不安全**：
    
    -   线程不安全指的是在多线程环境下，对共享数据的访问操作可能会导致数据的不一致性或损坏。线程不安全的操作或数据结构在并发访问时无法保证其内部状态的一致性，可能会导致意外的结果或程序错误。
    -   线程不安全的实现通常没有考虑到并发访问的情况，没有采取适当的同步措施来保护共享资源的访问，因此可能会出现竞态条件和其他并发问题。

举例来说，如果多个线程同时尝试向同一个数组中添加元素，而该数组的添加操作没有进行适当的同步控制，那么就可能导致线程不安全的情况，如数据覆盖、越界访问等。为了保证线程安全，需要在并发访问共享资源时使用适当的同步机制来确保数据的一致性。


## 调度

抢占式调度：随机性。
- 根据优先级抢占。
- 优先级不保证绝对先执行完，只是概率大。

非抢占式调度（分时调度模型）：所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间片
