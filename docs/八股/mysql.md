## mysql b+树和b树
B+树和B树都是常用的索引结构，用于在数据库中进行高效的数据检索。

它们的主要区别在于叶子节点的结构和使用方式。

B树（B-Tree）是一种平衡多路搜索树，它的特点是每个节点可以存储多个关键字和对应的数据指针。

B树的节点分为内部节点和叶子节点，内部节点存储关键字和指向子节点的指针，叶子节点存储关键字和对应的数据指针。

B树的特点是所有叶子节点都在同一层级上，通过内部节点的指针可以快速定位到叶子节点。

B树适用于磁盘存储等场景，可以减少磁盘I/O次数，提高检索效率。

B+树（B+ Tree）是在B树的基础上进行了改进，它的特点是所有关键字都存储在叶子节点上，而内部节点只存储关键字和指向子节点的指针。

叶子节点之间通过指针连接形成一个有序链表，可以支持范围查询和顺序遍历。

B+树的内部节点相对较小，可以存储更多的关键字，减少了树的高度，提高了检索效率。B+树常用于数据库索引的实现，可以支持高效的范围查询和排序操作。

总结来说，B树适用于磁盘存储等场景，可以减少磁盘I/O次数；而B+树适用于数据库索引等场景，可以支持范围查询和顺序遍历。两者都是常用的索引结构，根据具体的应用场景选择适合的索引结构可以提高数据库的性能。

## 联合索引底层存储结构(和其他种类的索引的存储结构有什么区别?)

联合索引是数据库中一种常见的索引类型，它允许在多个列上创建索引，以提高查询性能。与单列索引相比，联合索引的底层存储结构有一些区别，主要体现在如何组织和存储索引数据的方式上。

1.  **存储数据的组织方式**：
    
    -   单列索引：单列索引只包含一个列的值和指向相应数据行的指针。通常，单列索引按照列值的大小顺序来组织存储数据。
    -   联合索引：联合索引则包含多个列的值，以及指向相应数据行的指针。联合索引可以按照多个列值的组合来组织存储数据，这意味着可以根据多个列的值来定位数据行。
2.  **查询时的性能影响**：
    
    -   单列索引：单列索引适合用于只涉及单个列的查询。当查询条件涉及到索引列时，数据库可以更快地定位到匹配的数据行。
    -   联合索引：联合索引适合用于涉及多个列的查询。当查询涉及到联合索引中的多个列时，数据库可以利用索引中列值的组合来快速定位匹配的数据行。
3.  **索引维护的复杂性**：
    
    -   单列索引：单列索引的维护相对简单，因为它只需要维护单个列的值和指针。
    -   联合索引：联合索引的维护相对复杂一些，因为它需要考虑多个列值的组合。当表中的数据发生变化时，数据库需要确保联合索引中的多个列值的组合保持有序，这可能需要更多的资源和时间。

联合索引在适当的情况下可以提供更好的查询性能，特别是对于涉及到联合索引中列值的组合的查询。然而，需要注意的是，联合索引的创建和维护可能会带来一些额外的开销，并且需要根据具体的查询需求和数据模式来合理选择索引策略。

## 联合索引的叶子节点存的什么内容?

联合索引的叶子节点存储的是索引列的值以及指向对应数据行的指针（聚集索引键值）。在联合索引中，叶子节点包含了多个列的值，以及指向对应数据行的指针（者聚集索引键值）的组合。

具体来说，叶子节点中存储了索引列的实际值，以及一个指向相应数据行的指针（者聚集索引键值）。这样，当数据库引擎根据联合索引执行查询时，它可以通过索引中的列值找到对应的叶子节点，然后使用叶子节点中的指针（键值）来定位到相应的数据行。

联合索引的叶子节点存储了索引列的值和指向数据行的指针（键值）的组合，这样可以在查询时快速定位到匹配的数据行。

## 事务会不会自动提交?

MySQL 默认开启事务自动提交模式，即除非显式的开启事务（BEGIN 或 START TRANSACTION），否则每条 SOL 语句都会被当做一个单独的事务自动执行。

要启用自动提交，在执行任何DML（Data Manipulation Language）语句（例如INSERT、UPDATE、DELETE）之前，可以使用以下语句开启自动提交：

```
SET autocommit = 1;
```

或者可以在连接到数据库时在连接字符串中指定`autocommit`参数为1。

```
mysql -u username -p -h hostname dbname --autocommit=1
```

这将使得MySQL会话处于自动提交模式，这意味着每个单独的DML语句都将自动成为一个事务，并在执行完成后立即提交。

如果想要禁用自动提交，可以使用以下语句：

```
SET autocommit = 0;
```

或者在连接字符串中指定`autocommit`参数为0。

## 事务的ACID

- 原子性（Atomicity）：事务中的所有操作，要么全部成功，要么全部失败回滚。
- 一致性（Consistency）：事务执行前后，数据库都应该保持一致性状态。
- 隔离性（Isolation）：多个并发的事务之间应该互相隔离，避免互相干扰。
- 持久性（Durability）：事务提交后，对数据库的修改应该永久保存，即使系统故障也不应该丢失。

PS：一致性：数据库内部的**完整性**约束、声明性约束。转账，两用户总金额不变。

## 原子性、一致性、隔离性和持久性他们分别是有什么作用？

- 原子性：保证（事务中所有操作要么全部成功，要么全部失败回滚），避免因为部分操作失败导致数据不一致或错误的结果。
- 一致性：保证（事务执行前后，数据库都应该保持一致性状态），避免数据的不一致性。
- 隔离性：保证（多个并发的事务之间应该互相隔离，避免互相干扰），避免读取到未提交的数据或者脏数据，避免并发操作导致的数据冲突。
- 持久性：保证（事务提交后，对数据库的修改应该永久保存，即使系统故障也不应该丢失），避免数据的丢失和不可恢复。

## 事务并发的三种并发问题？脏读、不可重复读、幻读

脏读、幻读和不可重复读是数据库中的三种并发问题：

-   脏读（Dirty Read）：指一个事务读取了另一个事务未提交的数据，如果另一个事务回滚，则读取的数据是无效的。
-   幻读（Phantom Read）：指一个事务执行了两次查询，第二次查询发现了第一次查询没有发现的新数据或者没有查询到第一次查询中存在的数据。
-   不可重复读（Non-Repeatable Read）：指一个事务执行两次查询，第二次查询读取到了第一次查询中未提交的数据或另一个事务提交的数据。

这些问题的出现是由于多个事务同时访问数据库，而缺乏一定的隔离性和同步机制。为了解决这些问题，可以采用不同的隔离级别和锁机制来保证数据的一致性和可靠性。

## 事务的隔离级别有哪几种，作用分别是？

数据库事务的隔离级别有四种，分别为读未提交（Read Uncommitted）、读已提交（Read Committed）、可重复读（Repeatable Read）和串行化（Serializable）。

-   读未提交：最低的隔离级别，允许一个事务读取另一个事务未提交的数据。这种隔离级别会导致脏读、不可重复读和幻读问题。
-   读已提交：允许一个事务读取另一个事务已提交的数据，避免了脏读问题。但是仍然可能存在不可重复读和幻读问题。
-   可重复读：保证一个事务多次读取同一数据时，能够得到相同的结果，避免了不可重复读问题。但是仍然可能存在幻读问题。
-   串行化：最高的隔离级别，强制事务串行执行，避免了所有并发问题，但是会导致性能下降。

选择合适的隔离级别取决于应用场景和性能要求。通常情况下，可重复读,能够在保证数据一致性的同时兼顾性能，这也是mysql默认的隔离级别。

## MySQL默认的隔离级别是什么?

MySQL的默认隔离级别是可重复读（Repeatable Read）。在可重复读隔离级别下，事务可以读取其他事务已经提交的数据，但是不会看到其他事务未提交的数据。这意味着在同一个事务中多次读取相同的数据，将会得到相同的结果，即使其他事务对该数据进行了修改也是如此。

可重复读隔离级别保证了在同一个事务中多次读取数据时的一致性，但也可能导致一些并发问题，如幻读（Phantom Read）。MySQL提供了其他隔离级别来解决不同的并发问题，包括读未提交（Read Uncommitted）、读已提交（Read Committed）和串行化（Serializable）等。

需要注意的是，虽然MySQL的默认隔离级别是可重复读，但实际上可以在会话级别或全局级别进行更改，以满足特定的应用需求。

InnoDB 当前读下的幻读是通过间隙锁（gap_lock)来实现的。在事务A查询的时候，会锁住一个间隙，其它事务往这个间隙插入、删除等操作都是会被锁阻塞的。间隙锁和插入意向锁互斥，彻底解决了当前读下的幻读问题。

但是InnoDB 没有完全解决快照读下的幻读问题。