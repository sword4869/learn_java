@ mysql
## 1. mysql b+树和b树
B+树和B树都是常用的索引结构，用于在数据库中进行高效的数据检索。

它们的主要区别在于叶子节点的结构和使用方式。

B树（B-Tree）是一种平衡多路搜索树，它的特点是每个节点可以存储多个关键字和对应的数据指针。

B树的节点分为内部节点和叶子节点，内部节点存储关键字和指向子节点的指针，叶子节点存储关键字和对应的数据指针。

B树的特点是所有叶子节点都在同一层级上，通过内部节点的指针可以快速定位到叶子节点。

B+树（B+ Tree）是在B树的基础上进行了改进，它的特点是所有关键字都存储在叶子节点上，而内部节点只存储关键字和指向子节点的指针。

叶子节点之间通过指针连接形成一个有序链表。

B+树的内部节点相对较小，可以存储更多的关键字，减少了树的高度，提高了检索效率。

总结来说，B树适用于磁盘存储等场景，可以减少磁盘I/O次数；而B+树适用于数据库索引等场景，可以支持范围查询、顺序遍历、排序。两者都是常用的索引结构，根据具体的应用场景选择适合的索引结构可以提高数据库的性能。

## 2. 联合索引底层存储结构(和其他种类的索引的存储结构有什么区别?)

联合索引是数据库中一种常见的索引类型，它允许在多个列上创建索引，以提高查询性能。与单列索引相比

1.  **存储数据的组织方式**：
    
    -   单列索引只包含一个列的值和指向相应数据行的指针。通
    -   联合索引则包含多个列的值，以及指向相应数据行的指针。
2.  **查询时的性能影响**：
    
    -   当查询条件涉及到单个索引列时，数据库可以通过单列索引来更快地定位到匹配的数据行。
    -   联合索引在适当的情况下可以提供更好的查询性能，特别是对于涉及到联合索引中列值的组合的查询。
3.  **索引维护的复杂性**：
    
    -   单列索引的维护相对简单，因为它只需要维护单个列的值和指针。
    -   联合索引的创建和维护相对复杂一些，当表中的数据发生变化时，数据库需要确保联合索引中的多个列值的组合保持有序，这可能需要更多的资源和时间。

## 3. 联合索引的叶子节点存的什么内容?

联合索引的叶子节点存储的是索引列的值以及指向对应数据行的指针（聚集索引键值）。

## 4. 事务会不会自动提交?

MySQL 默认开启事务自动提交模式，每个单独的DML语句都将自动成为一个事务，并在执行完成后立即提交。

- 如何阻止自动提交？显式的开启事务（BEGIN 或 START TRANSACTION）。

- 如何开启自动提交：

    ```
    SET autocommit = 1;
    // DML语句
    ```

    或者可以在连接到数据库时在连接字符串中指定`autocommit`参数为1。

    ```
    mysql -u username -p -h hostname dbname --autocommit=1
    ```

- 如果想要禁用自动提交，可以使用以下语句：

    ```
    SET autocommit = 0;
    ```

    或者在连接字符串中指定`autocommit`参数为0。

## 5. 事务的ACID

- 原子性（Atomicity）：事务中的所有操作，要么全部成功，要么全部失败回滚。
- 一致性（Consistency）：事务执行前后，数据库都应该保持一致性状态。
- 隔离性（Isolation）：多个并发的事务之间应该互相隔离，避免互相干扰。
- 持久性（Durability）：事务提交后，对数据库的修改应该永久保存，即使系统故障也不应该丢失。

PS：一致性：数据库内部的**完整性**约束、声明性约束。转账，两用户总金额不变。

## 6. 原子性、一致性、隔离性和持久性他们分别是有什么作用？

- 原子性：保证（事务中所有操作要么全部成功，要么全部失败回滚），避免因为部分操作失败导致数据不一致或错误的结果。
- 一致性：保证（事务执行前后，数据库都应该保持一致性状态），避免数据的不一致性。
- 隔离性：保证（多个并发的事务之间应该互相隔离，避免互相干扰），避免读取到未提交的数据或者脏数据，避免并发操作导致的数据冲突。
- 持久性：保证（事务提交后，对数据库的修改应该永久保存，即使系统故障也不应该丢失），避免数据的丢失和不可恢复。

## 7. 事务并发的三种并发问题？脏读、不可重复读、幻读

脏读、幻读和不可重复读是数据库中的三种并发问题：

-   脏读（Dirty Read）：指一个事务读取了另一个事务未提交的数据，如果另一个事务回滚，则读取的数据是无效的。
-   不可重复读（Non-Repeatable Read）：指一个事务执行两次查询，第二次查询读取到了第一次查询中未提交的数据或另一个事务提交的数据。
-   幻读（Phantom Read）：指一个事务执行了两次查询，第二次查询发现了第一次查询没有发现的新数据或者没有查询到第一次查询中存在的数据。

这些问题的出现是由于多个事务同时访问数据库，而缺乏一定的隔离性和同步机制。为了解决这些问题，可以采用不同的隔离级别和锁机制来保证数据的一致性和可靠性。

## 8. 事务的隔离级别有哪几种，作用分别是？

数据库事务的隔离级别有四种，分别为读未提交（Read Uncommitted）、读已提交（Read Committed）、可重复读（Repeatable Read）和串行化（Serializable）。

-   读未提交：最低的隔离级别，允许一个事务读取另一个事务未提交的数据。这种隔离级别会导致脏读、不可重复读和幻读问题。
-   读已提交：允许一个事务读取另一个事务已提交的数据，避免了脏读问题。但是仍然可能存在不可重复读和幻读问题。
-   可重复读：保证一个事务多次读取同一数据时，能够得到相同的结果，避免了不可重复读问题。但是仍然可能存在幻读问题。
-   串行化：最高的隔离级别，强制事务串行执行，避免了所有并发问题，但是会导致性能下降。

选择合适的隔离级别取决于应用场景和性能要求。通常情况下，可重复读,能够在保证数据一致性的同时兼顾性能，这也是mysql默认的隔离级别。

## 9. MySQL默认的隔离级别是什么?

MySQL的默认隔离级别是可重复读（Repeatable Read）。

在可重复读隔离级别下，事务可以读取其他事务已经提交的数据，但是不会看到其他事务未提交的数据。这意味着在同一个事务中多次读取相同的数据，将会得到相同的结果，即使其他事务对该数据进行了修改也是如此。

可重复读隔离级别保证了在同一个事务中多次读取数据时的一致性，但也可能导致一些并发问题，如幻读（Phantom Read）。

需要注意的是，虽然MySQL的默认隔离级别是可重复读，但实际上可以在会话级别或全局级别进行更改，以满足特定的应用需求。

InnoDB 当前读下的幻读是通过间隙锁（gap_lock)来实现的。在事务A查询的时候，会锁住一个间隙，其它事务往这个间隙插入、删除等操作都是会被锁阻塞的。间隙锁和插入意向锁互斥，彻底解决了当前读下的幻读问题。

但是InnoDB 没有完全解决快照读下的幻读问题。

## 10. Buffer Pool

https://zhuanlan.zhihu.com/p/488819733

MySQL 的数据是存储在磁盘里的，每次去硬盘读数据太慢。

→ 引入缓存，缓冲池（Buffer Pool）来提高数据库的读写性能

→ 读。缓存池中存缓存页，将磁盘中的页换进来。

→ 比起在整个缓冲池中找空闲页，用free 链表存空闲页。

→ 链表是单哨兵双向循环链表。数据结点是控制块，一个控制块对应一个缓存页，在内存中控制块1-N集中存储，后面集中存1-N的缓存页，中间可能会有碎片空间。

→ 占据满了就要被淘汰才能换新的缓存页，那么引入LRU机制。LRU链表管理被使用过的页。

→ 被使用过的页，包括没被修改的clean页和被修改过的脏页。

→ 脏页由 flush 链表管理，比起修改一次就写一次的频繁IO，集中写入 flush 链表的写入性能更高。

→ 对LRU机制还做了2.5点优化：预读失效、缓存污染。

- 脏页什么时候会被刷入磁盘？
- 几个链表，几个页
- 预读失效的young、old过程
- 缓存污染