@ mysql
## 1. char varch

char 与 varchar 都可以描述字符串。

char是定长字符串，指定长度多长，就占用多少个字符，和字段值的长度无关 。而varchar是变长字符串，指定的长度为最大占用长度。

char的性能会更高些，varchar更省空间。


## 2. where与having区别
- 执行时机不同：where是分组之前进行过滤，不满足where条件，不参与分组；而having是分组
之后对结果进行过滤。
- 判断条件不同：where不能对聚合函数进行判断，而having可以。

## 3. 有哪些约束

6个

主键、外键；非空、唯一、；默认值、检查


## 4. 事务会不会自动提交?

MySQL 默认开启事务自动提交模式，每个单独的DML语句都将自动成为一个事务，并在执行完成后立即提交。

- 如何阻止自动提交？显式的开启事务（BEGIN 或 START TRANSACTION）。

- 如何开启自动提交：

    ```
    SET @@autocommit = 1;
    // DML语句
    ```

    或者可以在连接到数据库时在连接字符串中指定`autocommit`参数为1。

    ```
    mysql -u username -p -h hostname dbname --autocommit=1
    ```

- 如果想要禁用自动提交，可以使用以下语句：

    ```
    SET @@autocommit = 0;
    ```

    或者在连接字符串中指定`autocommit`参数为0。

## 5. 事务的ACID

- 原子性（Atomicity）：事务中的所有操作，要么全部成功，要么全部失败回滚。
- 一致性（Consistency）：事务执行前后，数据库都应该保持一致性状态。
- 隔离性（Isolation）：多个并发的事务之间应该互相隔离，避免互相干扰。
- 持久性（Durability）：事务提交后，对数据库的修改应该永久保存，即使系统故障也不应该丢失。

PS：一致性：数据库内部的**完整性**约束、声明性约束。转账，两用户总金额不变。

## 6. 原子性、一致性、隔离性和持久性他们分别是有什么作用？

- 原子性：保证（事务中所有操作要么全部成功，要么全部失败回滚），避免因为部分操作失败导致数据不一致或错误的结果。
- 一致性：保证（事务执行前后，数据库都应该保持一致性状态），避免数据的不一致性。
- 隔离性：保证（多个并发的事务之间应该互相隔离，避免互相干扰），避免读取到未提交的数据或者脏数据，避免并发操作导致的数据冲突。
- 持久性：保证（事务提交后，对数据库的修改应该永久保存，即使系统故障也不应该丢失），避免数据的丢失和不可恢复。

## 7. 事务并发的三种并发问题？脏读、不可重复读、幻读

脏读、幻读和不可重复读是数据库中的三种并发问题：

-   脏读（Dirty Read）：指一个事务读取了另一个事务未提交的数据，如果另一个事务回滚，则读取的数据是无效的。
-   不可重复读（Non-Repeatable Read）：指一个事务执行两次查询，但两次读取的数据不同（第二次查询读取到了第一次查询中未提交的数据或另一个事务提交的数据）。
-   幻读（Phantom Read）：指一个事务执行了两次查询，第二次查询发现了第一次查询没有发现的新数据或者没有查询到第一次查询中存在的数据。

这些问题的出现是由于多个事务同时访问数据库，而缺乏一定的隔离性和同步机制。为了解决这些问题，可以采用不同的隔离级别和锁机制来保证数据的一致性和可靠性。

## 8. 事务的隔离级别有哪几种，作用分别是？

数据库事务的隔离级别有四种，分别为读未提交（Read Uncommitted）、读已提交（Read Committed）、可重复读（Repeatable Read）和串行化（Serializable）。

-   读未提交：最低的隔离级别，允许一个事务读取另一个事务未提交的数据。这种隔离级别会导致脏读、不可重复读和幻读问题。
-   读已提交：允许一个事务读取另一个事务已提交的数据，避免了脏读问题。但是仍然可能存在不可重复读和幻读问题。
-   可重复读：保证一个事务多次读取同一数据时，能够得到相同的结果，避免了不可重复读问题。但是仍然可能存在幻读问题。
-   串行化：最高的隔离级别，强制事务串行执行，避免了所有并发问题，但是会导致性能下降。

选择合适的隔离级别取决于应用场景和性能要求。通常情况下，可重复读,能够在保证数据一致性的同时兼顾性能，这也是mysql默认的隔离级别。

## 9. MySQL默认的隔离级别是什么?

MySQL的默认隔离级别是可重复读（Repeatable Read）。

在可重复读隔离级别下，事务可以读取其他事务已经提交的数据，但是不会看到其他事务未提交的数据。这意味着在同一个事务中多次读取相同的数据，将会得到相同的结果，即使其他事务对该数据进行了修改也是如此。

可重复读隔离级别保证了在同一个事务中多次读取数据时的一致性，但也可能导致一些并发问题，如幻读（Phantom Read）。

需要注意的是，虽然MySQL的默认隔离级别是可重复读，但实际上可以在会话级别或全局级别进行更改，以满足特定的应用需求。

InnoDB 当前读下的幻读是通过间隙锁（gap_lock)来实现的。在事务A查询的时候，会锁住一个间隙，其它事务往这个间隙插入、删除等操作都是会被锁阻塞的。间隙锁和插入意向锁互斥，彻底解决了当前读下的幻读问题。

但是InnoDB 没有完全解决快照读下的幻读问题。

## 10. MySQL的体系结构

连接层、服务层、引擎层、存储层。


## 11. innodb的逻辑存储结构

表空间-段-区-页-行

页也是InnoDB 存储引擎磁盘管理的最小单元，16KB。

## 12. Buffer Pool

https://zhuanlan.zhihu.com/p/488819733

MySQL 的数据是存储在磁盘里的，每次去硬盘读数据太慢。

→ 引入缓存，缓冲池（Buffer Pool）来提高数据库的读写性能

→ 读。缓存池中存缓存页，将磁盘中的页换进来。

→ 比起在整个缓冲池中找空闲页，用free 链表存空闲页。

→ 链表是单哨兵双向循环链表。数据结点是控制块，一个控制块对应一个缓存页，在内存中控制块1-N集中存储，后面集中存1-N的缓存页，中间可能会有碎片空间。

→ 占据满了就要被淘汰才能换新的缓存页，那么引入LRU机制。LRU链表管理被使用过的页。

→ 被使用过的页，包括没被修改的clean页和被修改过的脏页。

→ 脏页由 flush 链表管理，比起修改一次就写一次的频繁IO，集中写入 flush 链表的写入性能更高。

→ 对LRU机制还做了2.5点优化：预读失效、缓存污染。

- 脏页什么时候会被刷入磁盘？
- 几个链表，几个页
- 预读失效的young、old过程
- 缓存污染


## 13. mysql的三种存储引擎

innodb(默认), myisam, memory


- InnoDB引擎, 支持事务, 而MyISAM不支持。
- InnoDB引擎, 支持行锁和表锁, 而MyISAM仅支持表锁, 不支持行锁。
- InnoDB引擎, 支持外键, 而MyISAM是不支持的
- memory存储表在内存中，不持久。
- 场景：要求事务的完整性、并发条件下的数据一致性、更新删除操作多，适合innodb；读和插入多，myisam；临时表和缓存，memory。


## 14. mysql的索引结构有哪些

B+树索引、hash索引、空间索引、全文索引。

## 15. mysql的索引有哪些

具体类型分为：主键索引、常规索引、唯一索引、全文索引

存储形式分为：聚集索引、二级索引。

## 16. 聚集索引和二级索引
- 聚集索引，将数据存储与索引放到了一块，叶子存行数据；二级索引，将数据与索引分开存储，叶子存主键。
- 聚集索引必须有,而且只有一个；二级索引可以有多个。
- 聚集索引直接查，二级索引还得回表查询。

## 17. 回表查询

先到二级索引中查找数据，找到主键值，

然后再到聚集索引中根据主键值，获取数据。

## 18. 聚集索引选取规则

1. 主键索引
2. 第一个唯一（UNIQUE）索引
3. 自动生成一个rowid

## 19. mysql b+树和b树

B+树和B树都是常用的索引结构，用于在数据库中进行高效的数据检索。

它们的主要区别在于叶子节点的结构和使用方式。

B树（B-Tree）是一种多叉路衡查找树
- 每个节点可以存储多个关键字和对应的数据指针。
- 非叶子节点和叶子节点都会存放数据。
- 非叶子节点存放指向子节点的指针。

B树的特点是所有叶子节点都在同一层级上，通过内部节点的指针可以快速定位到叶子节点。

b+树：
- 所有的数据都会出现在叶子节点。
- 叶子节点之间通过指针连接形成一个有序双向链表。
- 非叶子节点仅仅起到索引数据作用，只存储关键字和指向子节点的指针。

B+树的内部节点相对较小，可以存储更多的关键字，减少了树的高度，提高了检索效率。

总结来说，B树适用于磁盘存储等场景，可以减少磁盘I/O次数；而B+树适用于数据库索引等场景，可以支持范围查询、顺序遍历、排序。两者都是常用的索引结构，根据具体的应用场景选择适合的索引结构可以提高数据库的性能。

## 20. 为什么InnoDB存储引擎选择使用B+tree索引结构?

- 相对于二叉树，层级更少，搜索效率高
- 对于B-tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低
- 相对Hash索引，B+tree支持范围匹配及排序操作

## 21. InnoDB主键索引的B+tree高度为多高呢?

一页16KB。

innodb的指针6字节、主键即使为bigint为8字节。

一页存B+tree索引，可以存 n * 8 + (n + 1) * 6 = 16 * 1024 → n = 1170

一行数据大小为1K，一页可以有16行数据。那么1171 * 16 = 18736 行数据，得出当B+树高度为2的时候可以存储18736 行数据。

高度3：1171 x 1171 x 16 = 2200W 行数据


## 22. hash索引

Hash索引只能用于对等比较(=，in)，不支持范围查询

无法利用索引完成排序操作

查询效率高，不存在hash冲突时只需要一次检索就可以了，效率通常要高于B+tree索引


## 23. 联合索引底层存储结构(和其他种类的索引的存储结构有什么区别?)

联合索引是数据库中一种常见的索引类型，它允许在多个列上创建索引，以提高查询性能。与单列索引相比

1.  **存储数据的组织方式**：
    
    -   单列索引只包含一个列的值和指向相应数据行的指针。通
    -   联合索引则包含多个列的值，以及指向相应数据行的指针。
2.  **查询时的性能影响**：
    
    -   当查询条件涉及到单个索引列时，数据库可以通过单列索引来更快地定位到匹配的数据行。
    -   联合索引在适当的情况下可以提供更好的查询性能，特别是对于涉及到联合索引中列值的组合的查询。
3.  **索引维护的复杂性**：
    
    -   单列索引的维护相对简单，因为它只需要维护单个列的值和指针。
    -   联合索引的创建和维护相对复杂一些，当表中的数据发生变化时，数据库需要确保联合索引中的多个列值的组合保持有序，这可能需要更多的资源和时间。

## 24. 联合索引的叶子节点存的什么内容?

联合索引的叶子节点存储的是索引列的值以及指向对应数据行的指针（聚集索引键值）。

## 25. 索引失效

联合索引失效。
- 跳跃某一列，索引将会部分失效。
- 出现范围查询(>,<)，范围查询右侧的列索引失效。当范围查询使用>= 或 <= 时，走联合索引了。

在索引列上进行运算操作

字符串不加单引号。对于查询结果，没什么影响，但是数据库存在隐式类型转换，索引将失效。

模糊查询。如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。

or连接条件。连接条件中都有索引才不失效，否则都失效。

MySQL评估。MySQL在查询时，会评估使用索引的效率与走全表扫描的效率，如果走全表扫描更快，则放弃索引，走全表扫描。


## 26. 索引设计原则
1). 针对于数据量较大，且查询比较频繁的表建立索引。
2). 针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索
引。
3). 尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。
4). 如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。
5). 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，
避免回表，提高查询效率。
6). 要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增
删改的效率。
7). 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含
NULL值时，它可以更好地确定哪个索引最有效地用于查询。

## MySQL中的锁

按照锁的粒度分，分为以下三类：
- 全局锁：锁定数据库中的所有表。
- 表级锁（3-222）：每次操作锁住整张表。
- 行级锁（2）：每次操作锁住对应的行数据。

表级锁，主要分为以下三类：
- 表锁
- 元数据锁（meta data lock，MDL）
- 意向锁

表锁，分为两类：
- 表共享读锁（read lock）
- 表独占写锁（write lock）

元数据锁：DML和DDL
- 元数据共享读锁 SHARED_READ
- 元数据共享写锁 SHARED_WRITE
- 元数据排他锁 EXCLUSIVE


意向锁，分为两类：
- 意向共享锁(IS)
- 意向排他锁(IX)

对于行级锁，主要分为以下三类：
- 行锁（Record Lock）
- 间隙锁（Gap Lock）
- 临键锁（Next-Key Lock）


行锁：
- 共享锁（S）
- 排他锁（X）

|语句|表锁|行锁|
|-|-|-|
|`select`|SHARED_READ元数据读锁||
|`SELECT ... LOCK IN SHARE MODE`|SHARED_READ元数据读锁、意向共享锁IS|行共享锁|
|`SELECT ... FOR UPDATE`| SHARED_WRITE元数据写锁、意向排他锁IX|行排他锁|
|`insert` 、`update`、`delete`|SHARED_WRITE元数据写锁、意向排他锁IX|排他锁|
|`alter table ...`|EXCLUSIVE元数据排他锁||


## 数据库主从同步

1. MySQL master 将数据变更写入二进制日志binlog
2. MySQL slave 读取 master 的 binlog，写入到自己的中继日志relay log中。
3. MySQL slave 重放 relay log 中事件，将数据变更。
