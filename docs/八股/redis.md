- [🚀为什么要将热点数据放在Redis中](#为什么要将热点数据放在redis中)
- [🚀Redis是单线程还是多线程](#redis是单线程还是多线程)
- [Redis为什么是单线程的](#redis为什么是单线程的)
- [📕如果CPU成为Redis瓶颈，或者不想让服务器其他CUP核闲置，那怎么办？](#如果cpu成为redis瓶颈或者不想让服务器其他cup核闲置那怎么办)
- [🚀redis锁了解过吗](#redis锁了解过吗)
- [🚀redis的一致性问题？mysql的数据如何与redis进行同步呢？（双写一致性）](#redis的一致性问题mysql的数据如何与redis进行同步呢双写一致性)
- [🚀redis在生产中常见的问题](#redis在生产中常见的问题)
- [什么是bigkey、有什么危害、如何发现、如何删除](#什么是bigkey有什么危害如何发现如何删除)
- [📕redis是怎么判断当前的请求是用户A的请求还是用户B的请求(前端header中的key，然后解密)](#redis是怎么判断当前的请求是用户a的请求还是用户b的请求前端header中的key然后解密)
- [📕redis中的信息是加密的还是已经解密的](#redis中的信息是加密的还是已经解密的)
- [🚀redis怎么持久化](#redis怎么持久化)
- [Rdis的主从同步策略有什么](#rdis的主从同步策略有什么)
- [全量同步和增量同步区别？](#全量同步和增量同步区别)
- [什么时候执行全量同步？](#什么时候执行全量同步)
- [什么时候执行增量同步？](#什么时候执行增量同步)
- [第一次全量同步的过程](#第一次全量同步的过程)
- [增量同步的过程](#增量同步的过程)
- [repl\_backlog原理](#repl_backlog原理)
- [主从同步优化](#主从同步优化)
- [好的，你能介绍一下布隆过滤器吗？](#好的你能介绍一下布隆过滤器吗)
- [🚀redis有哪几种用来做容灾的架构设计策略（高可用）](#redis有哪几种用来做容灾的架构设计策略高可用)
- [哨兵的作用](#哨兵的作用)
- [哨兵如何判断一个redis实例是否健康？](#哨兵如何判断一个redis实例是否健康)
- [故障转移步骤有哪些？](#故障转移步骤有哪些)
- [如何选定一个slave作为新的master](#如何选定一个slave作为新的master)
- [📕哨兵模式中master挂了，接下来会做什么事情（Raft）](#哨兵模式中master挂了接下来会做什么事情raft)
- [🚀缓存同步/redis和mysql怎么保持数据一致性（延迟双删，异步更新缓存（基于binlog的同步机制））](#缓存同步redis和mysql怎么保持数据一致性延迟双删异步更新缓存基于binlog的同步机制)
- [redis中的数据被删除以后，热点数据打到数据库，怎么保证数据库不会被击垮](#redis中的数据被删除以后热点数据打到数据库怎么保证数据库不会被击垮)
- [如何分片](#如何分片)
- [redis分片集群有什么好处](#redis分片集群有什么好处)
- [多级缓存](#多级缓存)
- [redis过期key删除和内存淘汰是一个东西吗](#redis过期key删除和内存淘汰是一个东西吗)
- [redis过期key的删除策略](#redis过期key的删除策略)
- [Redis的内存淘汰策略](#redis的内存淘汰策略)
- [Setnx,知道吗? 用这个加锁有什么问题吗?怎么解决?](#setnx知道吗-用这个加锁有什么问题吗怎么解决)
- [🐕redis数据结构，用什么结构实现延迟消息队列](#redis数据结构用什么结构实现延迟消息队列)
- [不用redis做消息队列](#不用redis做消息队列)

---

## 🚀为什么要将热点数据放在Redis中
## 🚀Redis是单线程还是多线程

* 如果针对Redis的核心业务部分（命令处理），那就是单线程
* 如果是整个Redis，那就是多线程

Redis v4.0：引入多线程异步处理一些耗时较旧的任务，例如异步删除命令unlink

对于Redis的核心网络模型，在Redis 6.0之前确实都是单线程，6.0引入多线程处理网络 I/O，进一步提高对于多核CPU的利用率。


## Redis为什么是单线程的
redis是基于内存的，内存的读写速度非常快，CPU不是Redis的瓶颈。因此多线程并不会带来巨大的性能提升。

采用单线程，避免线程切换和竞态消耗，不存在锁的线程安全问题。

## 📕如果CPU成为Redis瓶颈，或者不想让服务器其他CUP核闲置，那怎么办？

可以考虑多起几个Redis进程，只要客户端分清哪些key放在哪个Redis进程上就可以了。

## 🚀redis锁了解过吗

## 🚀redis的一致性问题？mysql的数据如何与redis进行同步呢？（双写一致性）

三种方案：看业务需求

1. 可能不一致：延迟双删

2. 强一致：分布式锁的读写锁

3. 最终一致：异步通知（MQ；Canal）

## 🚀redis在生产中常见的问题

主从：高并发读

哨兵：高可用

分片集群：高并发写、海量数据存储

bigkey、热key

## 什么是bigkey、有什么危害、如何发现、如何删除

定义：
- Key本身的数据量过大：一个String类型的Key，它的值为5 MB
- 集合类型的成员数过多：list、set、zset
- Key中成员的数据量过大：一个Hash类型的Key，它的成员数量虽然只有1,000个，但这些成员的Value（值）总大小为100 MB

危害：
- 少量的QPS网络阻塞
- 数据倾斜，分片的内存占用不均衡
- 序列化和反序列而阻塞
- 集合运算而阻塞
- 主动删除或过期删除而阻塞
- 主从复制太久

如何发现：
- redis-cli --bigkeys: 分析所有，但只提供每类型的top1，容易漏过。
- 自定义scan扫描：利用strlen、hlen等命令判断key的长度。
- Redis-Rdb-Tools：可以离线分析RDB快照文件
- 网络监控：监控进出Redis的网络数据，超出预警值时主动告警

解决方案：
- 单个key拆分成几个key-value
- 集合拆分个数。
- string类型的big key，尽量不要存入Redis中，可以使用文档型数据库MongoDB或缓存到CDN上。

如何删除：直接删除这样的key也需要耗费很长时间，导致Redis主线程阻塞
- redis 4.0 前：如果是集合类型，先逐个删除子元素，最后删除BigKey
- Redis在4.0：unlink异步删除

## 📕redis是怎么判断当前的请求是用户A的请求还是用户B的请求(前端header中的key，然后解密)

## 📕redis中的信息是加密的还是已经解密的

## 🚀redis怎么持久化


## Rdis的主从同步策略有什么

全量同步和增量同步

## 全量同步和增量同步区别？

- 全量同步：master将完整内存数据生成RDB，发送RDB到slave。后续命令则记录在repl_baklog，逐个发送给slave。
- 增量同步：slave提交自己的offset到master，master获取repl_baklog中从offset之后的命令给slave

## 什么时候执行全量同步？

- slave节点第一次连接master节点时
- slave节点断开时间太久，repl_baklog中的offset已经被覆盖时

## 什么时候执行增量同步？

- slave节点断开又恢复，并且在repl_baklog中能找到offset时


## 第一次全量同步的过程

主从第一次建立连接时，会执行**全量同步**。


1. slave节点先尝试请求增量同步，并发送replid和offset
2. master节点判断replid来确实slave节点是否是第一次同步，发现不一致，拒绝增量同步
3. 是第一次则执行全量同步。master发送自己的replid和offset给slave，slave继承master的replid。
4. master执行bgsave，发送RDB到slave
5. slave清空本地数据，加载master的RDB
6. master将生成RDB期间的命令记录在repl_baklog，并持续将log中的命令发送给slave
7. slave执行接收到的命令，保持与master之间的同步

## 增量同步的过程

slave重启后，与master同步。

1. slave节点先尝试请求增量同步，并发送replid和offset
2. master节点判断replid来确实slave节点是否是第一次同步。
3. 不是第一次同步，则回复continue。
4. master发送自己repl_baclog中offset后的命令
5. slave执行接收到的命令，保持与master之间的同步

## repl_backlog原理

环形数组。

1. 如果宕机时间不久，那么正常slave追master的offset，做增加同步。
2. 如果宕机时间太久，slave在repl_baklog中能找不到offset时，无法完成增量同步了。只能做全量同步。

## 主从同步优化

1. 全量同步
   
   - 无磁盘复制。当磁盘慢而网络带宽高时，在master中开启无磁盘复制，直接将rdb通过网络写给slave。

   - 单节点小内存。减少rdb文件大小。

2. 增量同步：为了尽可能避免全量同步

    - 提高repl_baklog的大小
    - 发现slave宕机时尽快实现故障恢复

3. 主从从结构
   
   master上的slave节点数量过度时，则可以采用主-从-从链式结构，减少master压力

## 好的，你能介绍一下布隆过滤器吗？

**布隆过滤器主要是用于检索一个元素是否在一个集合中**。

实现；redisson实现的布隆过滤器。

底层：hash函数+位图数组。
- hash函数映射key到数组中的某个位置上。0不存在，1存在。
- 因为hash冲突，1存在也可能是别的key。所以多次hash，所有的都是1才极大可能存在，只要有一个是0，那么就不存在。

缺点：误判。

误判因素：数组太短，hash函数次数，hash函数质量（加密hash、高级hash）。

误判率一般设置概不会超过5%。

## 🚀redis有哪几种用来做容灾的架构设计策略（高可用）

主从复制，哨兵，集群

## 哨兵的作用

- **监控**：基于心跳机制监测服务状态，哨兵不断检查master和slave是否按预期工作
- **自动故障恢复**：节点挂了就会去自动重启。
- **故障转移**：如果master故障，哨兵会将一个slave提升为master。当故障实例恢复后也以新的master为主
- **通知**：哨兵充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送给Redis的客户端


## 哨兵如何判断一个redis实例是否健康？

- 每隔1秒发送一次ping命令，如果超过一定时间没有相向则认为是主观下线
- 如果超过指定数量quorum的哨兵们都认为实例主观下线，则判定服务客观下线

## 故障转移步骤有哪些？

- 首先选定一个slave作为新的master，执行`slaveof no one`
- 然后让所有节点都执行`slaveof 新master`
- 修改故障节点的配置，添加`slaveof 新master`

## 如何选定一个slave作为新的master

1. 排除slave节点与master节点**断开时间**超过指定值的slave节点
2. 选择slave-**priority值最小**（优先级最高）的节点。如果是0则永不参与选举。
3. 如果slave-priority一样，则选择**offset最大数据越新**的slave节点。
4. 如果还不行，选**运行id**最小的slave节点。

## 📕哨兵模式中master挂了，接下来会做什么事情（Raft）

## 🚀缓存同步/redis和mysql怎么保持数据一致性（延迟双删，异步更新缓存（基于binlog的同步机制））

缓存与数据库的同步。

缓存数据同步的常见方式有三种：

**设置有效期**：给缓存设置有效期，到期后自动删除。再次查询时更新

- 优势：简单、方便
- 缺点：时效性差，缓存过期之前可能不一致
- 场景：更新频率较低，时效性要求低的业务

**同步双写**：在修改数据库的同时，直接修改缓存

- 优势：时效性强，缓存与数据库强一致
- 缺点：有代码侵入，耦合度高；
- 场景：对一致性、时效性要求较高的缓存数据

**异步通知**：修改数据库时发送事件通知，相关服务监听到通知后修改缓存数据。有MQ异步通知或canal监听binlog。

- 优势：低耦合，可以同时通知多个缓存服务
- 缺点：时效性一般，可能存在中间不一致状态
- 场景：时效性要求一般，有多个服务需要同步

MQ异步通知：少量代码侵入
- 商品服务写完数据库后，发布消息到MQ中后才结束。
- 缓存服务监听MQ消息，更新缓存

canal监听binlog：代码零侵入
- 商品服务写完数据库后，业务直接结束
- Canal监听MySQL的binlog变化，当发现变化后，立即通知缓存服务
- 缓存服务接收到canal通知，更新缓存

canal原理：
canal把自己伪装成MySQL的一个slave节点，基于mysql的主从同步。

## redis中的数据被删除以后，热点数据打到数据库，怎么保证数据库不会被击垮

构建mysql集群

## 如何分片

1. 将每个master节点映射到散列插槽上。

2. redis获取数据key的有效部分，用CRC16算法得到一个hash值后取余，得到插槽值。

3. 从而将数据分配到不同的节点上，每个节点负责存储和处理一部分数据。

## redis分片集群有什么好处

分片集群的好处如下：
-   高并发写。
-   扩展性：增加节点
-   海量存储：将数据分散存储在多个节点上
-   容错性：当某个节点发生故障或宕机时，其他节点仍然可以继续提供服务。
-   高可用性：通过复制机制，每个分片可以有多个副本，当主节点发生故障时，可以自动切换到备用节点.

限制：数据一致性、跨节点事务等问题，需要根据具体的业务需求和场景来选择合适的分片策略和解决方案。

## 多级缓存

传统的缓存：Tomcat→Redis→数据库

存在下面的问题：
- Tomcat的性能成为整个系统的瓶颈
- Redis缓存失效时，会对数据库产生冲击


多级缓存：浏览器缓存→nginx网关→nginx集群→redis→tomcat集群→数据库
- 浏览器访问静态资源时，优先读取浏览器本地缓存
- 访问非静态资源（ajax查询数据）时，访问服务端
- 请求到达Nginx后，优先读取Nginx本地缓存（OpenResty）
- 如果Nginx本地缓存未命中，则去直接查询Redis（不经过Tomcat）
- 如果Redis查询未命中，则查询Tomcat，优先查询JVM进程缓存（Caffeine）
- 如果JVM进程缓存未命中，则查询数据库

## redis过期key删除和内存淘汰是一个东西吗

不是。

过期删除是因为键过期而删除，而内存淘汰策略是因为内存空间不足而删除。

它们可以同时使用，以确保Redis的内存使用和键的过期管理。

## redis过期key的删除策略

- 惰性清理：每次访问key时判断是否过期，如果过期则删除。这种方式确保了过期键在被访问时被删除，但可能会导致一些性能开销。

- 定期清理：定期抽样部分key，判断是否过期，如果过期则删除。

   定期清理的两种模式：
   - SLOW模式：执行频率默认为每秒10次，每次不超过25ms
   - FAST模式：执行频率不固定，但两次间隔不低于2ms，每次耗时不超过1ms



## Redis的内存淘汰策略
Redis支持8种不同策略来选择要删除的key：
* noeviction： 不淘汰任何key，但是内存满时写操作会报错，默认就是这种策略。
* volatile-ttl： 对设置了TTL的key，比较key的剩余TTL值，越小越先被淘汰
* allkeys-random：对全体key ，随机进行淘汰。也就是直接从`db->dict`中随机挑选
* volatile-random：对设置了TTL的key ，随机进行淘汰。也就是从`db->expires`中随机挑选。
* allkeys-lru： 对全体key，基于LRU算法进行淘汰
* volatile-lru： 对设置了TTL的key，~
* allkeys-lfu： 对全体key，基于LFU算法进行淘汰
* volatile-lfu： 对设置了TTL的key，~
  
比较容易混淆的有两个：
* LRU（Least Recently Used），最少最近使用。用当前时间减去最后一次访问时间，这个值越大则淘汰优先级越高。
* LFU（Least Frequently Used），最少频率使用。统计一段时间内每个key的访问频率，值越小淘汰优先级越高。

## Setnx,知道吗? 用这个加锁有什么问题吗?怎么解决?

`SETNX` 是 Redis 中的一个命令，用于设置键的值，但仅当键不存在时才设置成功。

在分布式环境中，可以利用 `SETNX` 命令来实现简单的分布式锁。具体步骤如下：

1.  客户端通过 `SETNX` 命令尝试将一个特定的键作为锁的标识，并设置一个唯一的值作为锁的持有者标识。
2.  如果 `SETNX` 命令成功执行（返回值为 1），表示当前客户端成功获取了锁，可以执行后续操作。
3.  如果 `SETNX` 命令执行失败（返回值为 0），表示当前锁已被其他客户端持有，当前客户端未获取到锁，需要等待一段时间后重新尝试获取锁。

它也存在一些问题：

1.  **无法设置过期时间**：`SETNX` 命令本身不支持设置键的过期时间，因此当持有锁的客户端发生异常或程序出现问题时，可能导致锁无法被释放，造成死锁或锁泄露问题。
    
2.  **非原子性操作**：尽管 `SETNX` 命令本身是原子性的，但是获取锁和释放锁通常需要多个命令的组合，例如获取锁时需要执行 `SETNX`，释放锁时需要执行 `DEL`。这种组合操作不是原子性的，可能会导致锁的不一致性问题。
    

为了解决这些问题，可以采用以下方法：

1.  **配合 `EXPIRE` 命令设置过期时间**：在获取锁成功后，使用 `EXPIRE` 命令为锁设置一个合理的过期时间，确保即使持有锁的客户端发生异常，锁也能在一定时间后自动释放。
    
2.  **使用 Lua 脚本确保原子性**：将获取锁和释放锁的操作封装在 Lua 脚本中执行，Lua 脚本可以在 Redis 中以原子性的方式执行多个命令，确保获取锁和释放锁的操作是原子性的，避免了竞态条件的发生。
    
更复杂的分布式锁方案Redlock：

这些方案通常基于多个 Redis 实例，并结合超时机制和复制机制来保证分布式锁的安全性和可靠性。


## 🐕redis数据结构，用什么结构实现延迟消息队列
对于实现延迟消息队列，可以使用有序集合（Sorted Set）结构来存储消息。将消息的执行时间作为分数，消息内容作为成员，按照分数进行排序。通过定时任务或者轮询方式，检查有序集合中的消息，当消息的执行时间到达时，取出消息进行处理。

- 具体实现时，可以使用Redis的ZADD命令将消息添加到有序集合中，使用ZRANGEBYSCORE命令按照分数范围获取需要执行的消息，使用ZREM命令从有序集合中删除已经执行的消息。

- 添加消息：使用有序集合的ZADD命令，将消息作为成员添加到有序集合中，同时指定一个分数（score）作为消息的优先级或执行时间。分数可以是一个时间戳或其他有序的值，用于排序消息。

- 取出消息：使用有序集合的ZRANGE命令，按照分数范围获取需要执行的消息。可以设置获取的消息数量，也可以设置获取的分数范围。获取到的消息是按照分数从小到大排序的。

- 执行消息：获取到消息后，进行相应的处理操作。可以是执行具体的业务逻辑，发送消息给其他系统，或者进行其他操作。

- 删除消息：使用有序集合的ZREM命令，从有序集合中删除已经执行的消息。删除消息可以避免重复处理。

- 定时任务或轮询：为了实现消息的自动执行，可以使用定时任务或者轮询方式，定期检查有序集合中的消息。根据消息的分数判断是否到达执行时间，如果是则取出消息进行处理。

有序集合实现消息队列的优势在于：

- 消息有序：有序集合会根据分数对消息进行排序，可以按照优先级或执行时间顺序处理消息。
- 支持延迟消息：通过设置不同的分数，可以实现延迟消息的处理，即在指定的时间后才会被取出执行。
- 支持优先级：可以根据分数设置消息的优先级，高优先级的消息会被优先处理。
- 支持批量获取：可以一次性获取多个消息，提高处理效率。
- 支持范围查询：可以按照分数范围获取消息，实现范围查询的功能。

需要注意的是，使用有序集合实现消息队列时，需要根据实际需求合理设置消息的分数和处理逻辑，以及定时任务或轮询的频率，以达到预期的消息处理效果。

使用Redis作为延迟消息队列的好处是，它具有高性能、持久化、可靠性等特点，并且提供了丰富的命令和数据结构，方便进行消息的添加、获取和删除操作。

## 不用redis做消息队列
1. 缓存资源的空间是非常宝贵的，都是存放热点数据。
2. 不可靠。redis是基于内存的，挂了数据就没了。
3. redis消息消费失败没有重试机制。
4. redis有内存淘汰机制，可能内存不足会丢失。