- [1. 集合](#1-集合)
  - [1.1. 集合体系](#11-集合体系)
  - [1.2. 包装类](#12-包装类)
- [2. Collection接口](#2-collection接口)
  - [2.1. 遍历](#21-遍历)
    - [2.1.1. 迭代器遍历](#211-迭代器遍历)
      - [2.1.1.1. 迭代器](#2111-迭代器)
    - [2.1.2. 增强for遍历](#212-增强for遍历)
    - [2.1.3. Lambda表达式遍历](#213-lambda表达式遍历)
- [3. List接口](#3-list接口)
  - [3.1. 遍历](#31-遍历)
- [4. ArrayList类](#4-arraylist类)
- [5. LinkedList类](#5-linkedlist类)
- [6. Set接口](#6-set接口)
- [7. HashSet](#7-hashset)
  - [7.1. 哈希值](#71-哈希值)
  - [7.2. 哈希表](#72-哈希表)
- [8. LinkedHashSet](#8-linkedhashset)
- [9. TreeSet](#9-treeset)
  - [9.1. 自定义比较](#91-自定义比较)
    - [9.1.1. 默认排序](#911-默认排序)
    - [9.1.2. 比较器排序](#912-比较器排序)
- [10. Collections工具类](#10-collections工具类)
- [11. 不可变集合](#11-不可变集合)
  - [11.1. list](#111-list)
  - [11.2. set](#112-set)
  - [11.3. map](#113-map)


---

## 1. 集合
### 1.1. 集合体系

![Alt text](../../../images/image-14.png)

- 有序: 存和取的元素顺序一致
- 可重复: 存储的元索可以重复
- 有索引: 可以通过索引操作元素


List接口：
- ArrayList：底层是数组结构实现，查询快、增删慢
- LinkedLis：底层是链表结构实现，查询慢、增删快
- Vector：已淘汰

Set接口：
- HashSet：无序
- LinkedHashSet：有序
- TreeSet：可排序

![Alt text](../../../images/image-35.png)

### 1.2. 包装类

包装类：基本数据类型对应的引用类型。

![](../../../images/image_id=410910.jpg)

![](../../../images/image_id=410905.jpg)

![](../../../images/image_id=413856.jpg)

理由：Object多态和集合需要

![](../../../images/image_id=413857.jpg)

![](../../../images/image_id=413859.jpg)

![](../../../images/image_id=413863.jpg)

![](../../../images/image_id=413864.jpg)

![](../../../images/image_id=413866.jpg)

![](../../../images/image_id=413867.jpg)

![](../../../images/image_id=413871.jpg)

## 2. Collection接口

Collection是单列集合的顶层接口，所有方法被List和Set共享。

![Alt text](../../../images/image-16.png)

```java
/* 创建集合的对象 */

// 1. 限定集合中存储数据的类型
// ArrayList<String> list = new ArrayList<String>();
ArrayList<String> list = new ArrayList<>();     // 简写不用再写类型
list.add("abc");

// 2.任意类型
ArrayList list = new ArrayList();
list.add(123);  // add(Object e)
list.add("abc");
```


```java
import java.util.ArrayList;
import java.util.Collection;

public class A01_CollectionDemo1 {
    public static void main(String[] args) {
        // Collection是一个接口,我们不能直接创建他的对象。
        // 所以，现在我们学习他的方法时，只能创建他实现类的对象。
        Collection<String> coll = new ArrayList<>();

        // 1.添加元素: 将指定的元素添加到此集合的尾部
        // 细节1：如果我们要往List系列集合中添加数据，那么方法永远返回true，因为List系列的是允许元素重复的。
        // 细节2：如果我们要往Set系列集合中添加数据，如果当前要添加元素不存在，方法返回true，表示添加成功。
        //   如果当前要添加的元素已经存在，方法返回false，表示添加失败。因为Set系列的集合不允许重复。
        coll.add("aaa");
        coll.add("bbb");
        coll.add("ccc");

        // 2. 打印
        // JDK7: 打印对象不是地址值，而是集合中存储数据内容
        // 如果是基本数据类型和String，那ok
        // 如果是自定义类型，那需要重写toString()
        System.out.println(coll);

        // 3.判断元素是否包含
        // 细节：底层是遍历各元素，依赖equals方法进行判断是否存在的。
        // 所以，如果集合中存储的是自定义对象，那么在javabean类中，一定要重写这个类的equals方法。
        boolean result1 = coll.contains("bbb");
        System.out.println(result1);

        // 4.判断集合是否为空
        boolean result2 = coll.isEmpty();
        System.out.println(result2);//false

        // 5.获取集合的长度
        coll.add("ddd");
        int size = coll.size();
        System.out.println(size);//3

        // 6.删除
        // 细节1：因为Collection里面定义的是共性的方法，所以此时不能通过索引进行删除。只能通过元素的对象进行删除。
        // 细节2：方法会有一个布尔类型的返回值，删除成功返回true，删除失败返回false
        // 如果要删除的元素不存在，就会删除失败。
        System.out.println(coll.remove("aaa"));
        System.out.println(coll);

        // 7.清空
        coll.clear();
    }
}
```

### 2.1. 遍历

PS：不用普通的for索引遍历，因为Set没有索引。

Collection系列集合三种通用的遍历方式：
1. 迭代器遍历
2. 增强for遍历
3. lambda表达式遍历

如果需要删除元素，用迭代器遍历；如果只是遍历，用后两个。

#### 2.1.1. 迭代器遍历

迭代器遍历相关的四个方法：
- `Iterator<E> iterator()`：返回容器对象的迭代器对象，默认指向当前集合的0索引
- `boolean hasNext()`：判断当前指针位置是否有元素，有返回true，没有返回false
- `E next()`：获取当前指向的元素并移动指针
- `void remove()`: 删除当前`next()`已获取的元素（而不是指针指向的元素）

![Alt text](../../../images/image-13.png)
```java
Collection<String> coll = new ArrayList<>();
coll.add("aaa");
coll.add("bbb");
coll.add("ccc");
coll.add("ddd");

Iterator<String> it = coll.iterator();
while (it.hasNext()) {
    String str = it.next();
    System.out.println(str);

    if (str.equals("ccc")) {
        it.remove();
        
        // 不能使用集合的方法
        // coll.remove("aaa");
        // java.util.ConcurrentModificationException
    }
}
System.out.println(coll);

String str = it.next();     // java.util.NoSuchElementException
```

细节注意点:
- 遍历完后，报错NoSuchElementException
- 迭代器遍历完毕, 指针不会复位。所以我们要继续第二次遍历集合，只能再次获取一个新的迭代器对象。
- 迭代器遍历时，不能用集合的方法进行增加或者删除。
    
    删除可以用迭代器的remove方法来删除。

    添加还是不行。


##### 2.1.1.1. 迭代器
![Alt text](../../../images/image-15.png)

#### 2.1.2. 增强for遍历

JDK5特性，内部原理就是一个迭代器。

单列集合和数组才能用。

```java
Collection<String> coll = new ArrayList<>();
coll.add("aaa");
coll.add("bbb");
coll.add("ccc");

// 用一个第三方变量，在循环的过程中依次表示集合中的每一个数据
for(String s : coll){
    System.out.println(s);
    // 修改增强for中的变量，不会影响原本的元素
    s = "ddd";
}
System.out.println(coll);   // [aaa, bbb, ccc]
```
#### 2.1.3. Lambda表达式遍历

JDK8特性

同样不能修改。
```java
Collection<String> coll = new ArrayList<>();
coll.add("aaa");
coll.add("bbb");
coll.add("ccc");

// 1.利用匿名内部类的形式
// 底层原理：
// 遍历集合，依次把得到的每一个元素，传递给下面的accept方法
coll.forEach(new Consumer<String>() {
    // s依次表示集合中的每一个数据
    @Override
    public void accept(String s) {
        System.out.println(s);
    }
});

// 2.利用Lambda表达式的形式
coll.forEach(s -> System.out.println(s));
```

## 3. List接口

![Alt text](../../../images/image-17.png)

```java
// 1.添加元素
// boolean Collection.add(E e)  将指定的元素添加到此集合的尾部
list.add("aaa");
list.add("ccc");
// void List.add(int index, E element)  将指定的元素插入此列表中的指定位置
// 细节：原来索引上的元素会依次往后移
list.add(1, "bbb");


// 2.删除元素
// boolean Collection.remove(Object o)  删除指定的元素，返回删除是否成功
boolean remove1 = list.remove("ccc");
System.out.println(remove1); //true
// E List.remove(int index)   删除指定索引处的元素，返回被删除的元素
String remove = list.remove(0);
System.out.println(remove); //aaa


// 3.修改元素
// E List.set(int index,E element)  修改指定索引处的元素，返回被修改的元素
String result = list.set(0, "QQQ");
System.out.println(result);

// 4. 获取元素
// E List.get(int index)  返回指定索引处的元素
String s = list.get(0);
System.out.println(s);
```

> `list.remove(1)` 删除的是1这个元素。还是1索引上的元素 ? 

删除的是1索引。因为在调用方法的时候。如果方法出现了重载现象优先调用实参跟形参类型一致的那个方法。`1` 是 `int`

```java
// boolean Collection.remove(Object o)
// E List.remove(int index)

// 此时 remove 方法是不会自动装箱的。所以对应int index
list.remove(1);

// 手动装箱。所以对应 Object o
Integer i = Integer.valueOf(1);
list.remove(i);
```

### 3.1. 遍历
List系列集合的五种遍历方式：
1. 迭代器：删除
2. 列表迭代器：添加和删除
3. 增强for：仅仅遍历
4. Lambda表达式：仅仅遍历
5. 普通for循环：操作索引

```java
List<String> list = new ArrayList<>();
list.add("aaa");
list.add("bbb");
list.add("ccc");

// 1.迭代器
Iterator<String> it = list.iterator();
while (it.hasNext()) {
    String str = it.next();
    System.out.println(str);
}

// 2.增强for
for (String s : list) {
    System.out.println(s);
}

// 3.Lambda表达式
list.forEach(s -> System.out.println(s));

// 4.普通for循环
// size方法跟get方法还有循环结合的方式，利用索引获取到集合中的每一个元素
for (int i = 0; i < list.size(); i++) {
    // i:依次表示集合中的每一个索引
    String s = list.get(i);
    System.out.println(s);
}

// 5.列表迭代器
// 获取一个列表迭代器的对象，里面的指针默认也是指向0索引的
// 额外添加了一个方法：在遍历的过程中，可以添加元素
ListIterator<String> list_it = list.listIterator();
while (list_it.hasNext()) {
    String str = list_it.next();
    if ("aaa".equals(str)) {
        // 删除当前已获取的元素（而不是指针指向的元素）
        list_it.remove();
    }
    if ("bbb".equals(str)) {
        // 在指针指向的位置添加元素（当前元素的后面）
        list_it.add("qqq");
    }
}
```

## 4. ArrayList类

底层数据结构是数组。

数组名字：elementDate，定义变量size。

![Alt text](../../../images/image-18.png)

![Alt text](../../../images/image-19.png)

![Alt text](../../../images/image-20.png)

![Alt text](../../../images/image-21.png)

## 5. LinkedList类

底层数据结构是双链表。

查询慢,增删快,但是如果操作的是首尾元素，速度极快，所以多了很多首尾操作的特有API。


![Alt text](../../../images/image-22.png)

![Alt text](../../../images/image-30.png)

![Alt text](../../../images/image-23.png)

## 6. Set接口

Set集合的方法上基本上与Collection的API一致


```java
Set<String> s = new HashSet<>();

// 1. 添加元素
// 如果当前元素是第一次添加，那么可以添加成功，返回true
// 如果当前元素是第二次添加，那么添加失败，返回false
System.out.println(s.add("张三")); // true
System.out.println(s.add("李四")); // true
System.out.println(s.add("王五")); // true
System.out.println(s.add("张三")); // false

// 2. 打印集合: 无序
System.out.println(s);// [李四, 张三, 王五]

// 3. 遍历
// 迭代器遍历
Iterator<String> it = s.iterator();
while (it.hasNext()) {
    String str = it.next();
    System.out.println(str);
}

// 增强for
for (String str : s) {
    System.out.println(str);
}

// Lambda表达式
s.forEach(str -> System.out.println(str));
```

## 7. HashSet

### 7.1. 哈希值

![Alt text](../../../images/image-31.png)

```java
Student s1 = new Student("zhangsan", 23);
Student s2 = new Student("zhangsan", 23);

// 1. 如果没有重写hashCode方法，不同对象计算出的哈希值是不同的
// 2. 如果已经重写hashcode方法，不同的对象只要属性值相同，计算出的哈希值就是一样的
System.out.println(s1.hashCode());// -1461067292
System.out.println(s2.hashCode());// -1461067292

// 3. 在小部分情况下，不同的属性值或者不同的地址值计算出来的哈希值也有可能一样(哈希碰撞)
// String类已经重写了hashCode方法，不同的字符串，只要内容一样，计算出的哈希值就是一样的
System.out.println("abc".hashCode());// 96354
System.out.println("acD".hashCode());// 96354
```
### 7.2. 哈希表

![Alt text](../../../images/image-32.png)

```java
import java.util.HashSet;

public class A02_HashSetDemo1 {
    public static void main(String[] args) {
        HashSet<Student> hs = new HashSet<Student>();

        // 创建学生对象
        Student s1 = new Student("林青霞", 30);
        Student s2 = new Student("张曼玉", 35);
        Student s3 = new Student("王祖贤", 33);

        hs.add(s1);
        hs.add(s2);
        hs.add(s3);

        // 遍历集合(增强for)
        for (Student s : hs) {
            System.out.println(s);
        }
        // Student{name='王祖贤', age=33}
        // Student{name='张曼玉', age=35}
        // Student{name='林青霞', age=30}
    }
}

class Student {
    private String name;
    private int age;

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o)
            return true;
        if (o == null || getClass() != o.getClass())
            return false;

        Student student = (Student) o;

        if (age != student.age)
            return false;
        return name != null ? name.equals(student.name) : student.name == null;
    }

    @Override
    public int hashCode() {
        int result = name != null ? name.hashCode() : 0;
        result = 31 * result + age;
        return result;
    }

    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}
```

## 8. LinkedHashSet

![Alt text](../../../images/image-33.png)

> 在以后如果要数据去重，我们使用哪个?
- 默认使用HashSet
- 如果要求去重且存取有序，才使用LinkedHashSet

```java
import java.util.LinkedHashSet;

public class A02_HashSetDemo1 {
    public static void main(String[] args) {
        LinkedHashSet<Student> hs = new LinkedHashSet<Student>();

        Student s1 = new Student("林青霞", 30);
        Student s2 = new Student("张曼玉", 35);
        Student s3 = new Student("王祖贤", 33);

        hs.add(s1);
        hs.add(s2);
        hs.add(s3);

        // 存取顺序
        System.out.println(hs);   
        // [Student{name='林青霞', age=30}, Student{name='张曼玉', age=35}, Student{name='王祖贤', age=33}]
    }
}
```

## 9. TreeSet

![Alt text](../../../images/image-34.png)

因为Integer等已经实现了接口 `Comparable`

![Alt text](../../../images/image-46.png)

```java
TreeSet<Integer> ts = new TreeSet<>();

// 1.添加元素
ts.add(4);
ts.add(5);
ts.add(1);
ts.add(3);
ts.add(2);

// 2.打印集合：排序
System.out.println(ts);     // [1, 2, 3, 4, 5]

// 3.遍历集合（三种遍历）
// 迭代器
Iterator<Integer> it = ts.iterator();
while(it.hasNext()){
    int i = it.next();
    System.out.println(i);
}
// 增强for
for (int t : ts) {
    System.out.println(t);
}
// lambda
ts.forEach( i-> System.out.println(i));
```

### 9.1. 自定义比较

自定义类必须按照以下任一种方式来实现比较，不然 TreeSet 添加元素报错 `ClassCastException`。

#### 9.1.1. 默认排序

实现Comparable接口，重写`compareTo`方法

```java
import java.util.TreeSet;

public class A02_TreeSet {
    public static void main(String[] args) {
        TreeSet<Student> ts = new TreeSet<Student>();

        // 创建学生对象
        Student s1 = new Student("aaa", 30);
        Student s2 = new Student("bbb", 35);
        Student s3 = new Student("ccc", 33);

        ts.add(s1);
        ts.add(s2);
        ts.add(s3);

        // 遍历集合(增强for)
        for (Student s : ts) {
            System.out.println(s);
        }
        // Student{name='aaa', age=30}
        // Student{name='ccc', age=33}
        // Student{name='bbb', age=35
    }
}

class Student implements Comparable<Student>{
    private String name;
    private int age;

    public Student() {}

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {return name;}

    public void setName(String name) {this.name = name;}

    public int getAge() {return age;}

    public void setAge(int age) {this.age = age;}

    @Override
    public boolean equals(Object o) {
        if (this == o)
            return true;
        if (o == null || getClass() != o.getClass())
            return false;

        Student student = (Student) o;

        if (age != student.age)
            return false;
        return name != null ? name.equals(student.name) : student.name == null;
    }

    @Override
    public int hashCode() {
        int result = name != null ? name.hashCode() : 0;
        result = 31 * result + age;
        return result;
    }

    // this: 要添加的元素
    // s: 已存在于红黑树中的元素
    // 返回值：
    //      0 表示要添加的元素重复，不添加；
    //      正数 表示要添加的元素大于s，添加到右子树；
    //      负数 表示要添加的元素小于s，添加到左子树
    @Override
    public int compareTo(Student s) {
        System.out.println(this + "..." + s);
        // 按照年龄从小到大排序
        int num = this.getAge() - s.getAge();
        // 年龄相同，按照姓名的字母顺序排序
        int num2 = num == 0 ? this.getName().compareTo(s.getName()) : num;
        return num2;
        // Student{name='aaa', age=30}...Student{name='aaa', age=30}
        // Student{name='bbb', age=35}...Student{name='aaa', age=30}
        // Student{name='ccc', age=33}...Student{name='aaa', age=30}
        // Student{name='ccc', age=33}...Student{name='bbb', age=35}
    }
}
```

#### 9.1.2. 比较器排序

TresSet构造传递比较器，重写`compare`方法。

PS：当默认排序和比较器排序同时存在时，以比较器排序为准。

```java
// o1:表示当前要添加的元素
// o2：表示已经在红黑树存在的元素
// 返回值规则跟之前是一样的
// FunctionalInterface。可以简化为lambda
TreeSet<String> ts = new TreeSet<>(new Comparator<String>() {
    @Override
    public int compare(String o1, String o2) {
        // 按照字符串的长度升序排序
        int num = o1.length() - o2.length();
        // 长度相同，按照字母顺序排序
        int num2 = num == 0 ? o1.compareTo(o2) : num;
        return num2;
    }
});

ts.add("c");
ts.add("ab");
ts.add("df");
ts.add("qwer");

System.out.println(ts);     // [c, ab, df, qwer]
```

```java
public class A02_TreeSet {
    public static void main(String[] args) {
        TreeSet<Student> ts = new TreeSet<Student>(new Comparator<Student>() {
            @Override
            public int compare(Student s1, Student s2) {
                int num = s2.getAge() - s1.getAge();
                int num2 = num == 0 ? s1.getName().compareTo(s2.getName()) : num;
                return num2;
            }
        });

        // 创建学生对象
        Student s1 = new Student("aaa", 30);
        Student s2 = new Student("bbb", 35);
        Student s3 = new Student("ccc", 33);

        ts.add(s1);
        ts.add(s2);
        ts.add(s3);

        // 遍历集合(增强for)
        for (Student s : ts) {
            System.out.println(s);
        }
        // Student{name='aaa', age=30}
        // Student{name='ccc', age=33}
        // Student{name='bbb', age=35
    }
}
```

## 10. Collections工具类

仅限单列集合。

![Alt text](../../../images/image-48.png)

```java
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;

public class CollectionsDemo2 {
    public static void main(String[] args) {
        System.out.println("-------------sort默认规则--------------------------");
        ArrayList<Integer> list1 = new ArrayList<>();
        //addAll  批量添加元素
        Collections.addAll(list1, 10, 1, 2, 4, 8, 5, 9, 6, 7, 3);

        //shuffle 打乱
        Collections.shuffle(list1);

        // 默认规则，需要重写Comparable接口compareTo方法。Integer已经实现，按照从小打大的顺序排列
        // 如果是自定义对象，需要自己指定规则
        Collections.sort(list1);
        System.out.println(list1);

        Collections.sort(list1, new Comparator<Integer>() {
            @Override
            public int compare(Integer o1, Integer o2) {
                return o2 - o1;
            }
        });
        System.out.println(list1);

        Collections.sort(list1, (o1, o2) -> o2 - o1);
        System.out.println(list1);

        System.out.println("-------------binarySearch--------------------------");
        // 需要元素有序
        ArrayList<Integer> list2 = new ArrayList<>();
        Collections.addAll(list2, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        System.out.println(Collections.binarySearch(list2, 9)); // 8
        System.out.println(Collections.binarySearch(list2, 1)); // 0
        System.out.println(Collections.binarySearch(list2, 20));    // -11

        System.out.println("-------------copy--------------------------");
        ArrayList<Integer> list3 = new ArrayList<>();
        ArrayList<Integer> list4 = new ArrayList<>();
        Collections.addAll(list3, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        Collections.addAll(list4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        // dest <- src
        // 会覆盖原来的元素
        // 注意点：如果list3的长度 > list4的长度，方法会报错
        Collections.copy(list4, list3);
        System.out.println(list3);
        System.out.println(list4);

        System.out.println("-------------fill--------------------------");
        ArrayList<Integer> list5 = new ArrayList<>();
        Collections.addAll(list5, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        // 把集合中现有的所有数据，都修改为指定数据
        Collections.fill(list5, 100);
        System.out.println(list5);

        System.out.println("-------------max/min--------------------------");
        ArrayList<Integer> list6 = new ArrayList<>();
        Collections.addAll(list6, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        // 求最大值或者最小值
        System.out.println(Collections.max(list6));
        System.out.println(Collections.min(list6));

        System.out.println("-------------max/min指定规则--------------------------");
        ArrayList<String> list7 = new ArrayList<>();
        Collections.addAll(list7, "a", "aa", "aaa", "aaaa");
        // String中默认是按照字母的abcdefg顺序进行排列的
        // 现在我要求最长的字符串
        // 默认的规则无法满足，可以自己指定规则
        // 求指定规则的最大值或者最小值
        System.out.println(Collections.max(list7, new Comparator<String>() {
            @Override
            public int compare(String o1, String o2) {
                return o1.length() - o2.length();
            }
        }));

        System.out.println("-------------swap--------------------------");
        ArrayList<Integer> list8 = new ArrayList<>();
        Collections.addAll(list8, 1, 2, 3);
        Collections.swap(list8, 0, 2);
        System.out.println(list8);

    }
}
```

## 11. 不可变集合
![Alt text](../../../images/image-49.png)

### 11.1. list
```java
// 一旦创建完毕之后，是无法进行修改的，在下面的代码中，只能进行查询操作
List<String> list = List.of("张三", "李四", "王五", "赵六");

System.out.println(list.get(0));
// list.remove("李四");
// list.add("aaa");
// list.set(0, "aaa");
```
### 11.2. set
```java
Set<String> set = Set.of("张三", "李四", "王五", "赵六");
for (String s : set) {
    System.out.println(s);
}
//set.remove("王五");


// 细节：当我们要获取一个不可变的Set集合时，里面的参数一定要保证唯一性
Set<String> set2 = Set.of("张三", "张三", "李四", "王五", "赵六");  // error
```
### 11.3. map
`Map.of()`方法，参数是有上限的，最多只能传递20个参数、即10个键值对键值。为什么不能用可变参数？因为可变参数不能写两个，`K...keys, V...values`报错。
```java
/* 10个键值对键值对个数小于等于10 */

// 一个key接着一个value
// 键是不能重复的
Map<String, String> map = Map.of("张三", "南京", "王五", "上海",
        "赵六", "广州", "孙七", "深圳", "周八", "杭州",
        "吴九", "宁波", "郑十", "苏州", "刘一", "无锡",
        "陈二", "嘉兴");

Set<String> keys = map.keySet();
for (String key : keys) {
    String value = map.get(key);
    System.out.println(key + "=" + value);
}
```
键值对的数量超过10个的。
```java
/* 键值对的数量超过10个 */
HashMap<String, String> hm = new HashMap<>();
hm.put("张三", "南京");
hm.put("李四", "北京");
hm.put("王五", "上海");
hm.put("赵六", "北京");
hm.put("孙七", "深圳");
hm.put("周八", "杭州");
hm.put("吴九", "宁波");
hm.put("郑十", "苏州");
hm.put("刘一", "无锡");
hm.put("陈二", "嘉兴");
hm.put("aaa", "111");

// 1. 底层写法：
// ①map的每个键值对Entry放入到Entry数组中
// ②使用Map.ofEntries()方法输入可变参数的Entry，转换为不可变的Map集合
Set<Map.Entry<String, String>> entries = hm.entrySet();
// toArray方法在底层会比较集合的长度跟数组的长度两者的大小
//      如果集合的长度 > 数组的长度 ：数据在数组中放不下，此时会根据实际数据的数，重新创建数组
//      如果集合的长度 <= 数组的长度：数据在数组中放的下，此时不会创建新的数，而是直接用
//      所以直接创建一个0大小的数组就行
Map.Entry[] arr1 = new Map.Entry[0];
Map.Entry[] arr2 = entries.toArray(arr1);
// 不可变的map集合
Map<String, String> map = Map.ofEntries(arr2);
System.out.println(map.get("aaa"));

// 2. 将上述代码简化为一行
Map<String, String> map2 = Map.ofEntries(hm.entrySet().toArray(new
Map.Entry[0]));
System.out.println(map2.get("aaa"));

// 3. JDK10特性：使用 Map封装上述代码的函数 Map.copyOf()
Map<String, String> map3 = Map.copyOf(hm);
System.out.println(map2.get("aaa"));
```