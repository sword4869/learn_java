- [1. 单例模式](#1-单例模式)
- [2. 懒汉式syn](#2-懒汉式syn)
- [3. 双检锁](#3-双检锁)
- [4. 登记（静态内部类）](#4-登记静态内部类)
- [5. 线程安全](#5-线程安全)


---
https://www.runoob.com/design-pattern/singleton-pattern.html

## 1. 单例模式

单例模式提供了访问其**唯一对象**的方式。该对象由该类自己创建，保证其唯一，外界可以直接访问、不需要实例化。

特点：
- **隐藏的构造函数**，不暴露给外界。
- **隐藏的静态变量**，通过调用自己隐藏的构造函数来初始化自身实例。
- **由静态方法返回静态变量**，暴露给外界。

作用：一个全局使用的类频繁地创建与销毁，比如IO；保证唯一对象，比如资源文件。

缺点：单例模式可被反射打破，获取到隐藏的构造函数。


各种单例设计模式
- 一般情况下，不建议使用第 1 种和第 2 种懒汉方式（加syn锁），建议使用第 3 种饿汉方式。
- 只有在要明确实现 lazy loading 效果时，才会使用第 5 种登记方式。
- 如果涉及到反序列化创建对象时，可以尝试使用第 6 种枚举方式。
- 如果有其他特殊的需求，可以考虑使用第 4 种双检锁方式（锁类）。

[6种code](../../../codes/design_mode/src/main/java/singleton/Singleton1.java)

## 2. 懒汉式syn

整个方法加锁，效率低。

## 3. 双检锁

懒汉+volatile+双检锁

关键点如下：
- **volatile** 关键字用于保证可见性。
- 使用双重检查的方式可以减少锁的竞争，提高性能。
    
    同步块对**整个类**加synchronized锁。
    
    **进入同步块前后检查 instance 是否已经被实例化**，如果都没有，则创建一个新的实例。

## 4. 登记（静态内部类）

静态内部类和静态内部类中的静态变量都是private

静态内部类中的静态变量是 懒汉式 + final + private

getInstance（）也是final。


## 5. 线程安全

都是线程安全的
- 懒汉式syn锁：synchonized锁
- 饿汉式： classloader 机制来线程安全，但不是lazy load。
- **双检锁**： synchonized锁，且lazy load
- 静态内部类：同样classloader 机制，但getInstance（）调用时才lazy load。
- 枚举